## Exercice 00 : display_file

Wesh, l'id√©e ici c'est de cr√©er un programme qui va afficher le contenu d'un fichier, un peu comme si tu faisais `cat` dans le terminal. Pour √ßa, on va utiliser les fonctions `open`, `read` et `write`. 

Alors voil√† ce qu'on fait : 

1. D'abord, on cr√©e un fichier `ft_display_file.c`.

```c
#include <unistd.h>
#include <fcntl.h>

#define BUF_SIZE 4096

void	ft_display_file(char *filename)
{
	int		fd;
	int		ret;
	char	buf[BUF_SIZE + 1];

	fd = open(filename, O_RDONLY);
	if (fd == -1)
	{
		write(2, "Cannot read file.\n", 18);
		return ;
	}
	while ((ret = read(fd, buf, BUF_SIZE)))
	{
		buf[ret] = '\0';
		write(1, buf, ret);
	}
	close(fd);
}

int		main(int argc, char **argv)
{
	if (argc < 2)
		write(2, "File name missing.\n", 19);
	else if (argc > 2)
		write(2, "Too many arguments.\n", 20);
	else
		ft_display_file(argv[1]);
	return (0);
}
```

Ce qui se passe ici, c'est que notre fonction `ft_display_file` va essayer d'ouvrir le fichier avec `open`. Si √ßa marche pas, √ßa veut dire que le fichier n'est pas lisible, alors on affiche "Cannot read file." sur la sortie d'erreur (file descriptor 2) et on se casse. Sinon, on lit le fichier avec `read` et on √©crit son contenu sur la sortie standard avec `write`, jusqu'√† ce qu'il n'y ait plus rien √† lire. √Ä la fin, on ferme le fichier avec `close`. 

Dans le `main`, on v√©rifie d'abord le nombre d'arguments. S'il n'y en a pas assez, on affiche "File name missing.". S'il y en a trop, on affiche "Too many arguments.". Sinon, on appelle notre fonction `ft_display_file` avec le nom du fichier. 

2. Ensuite, on cr√©e notre Makefile pour compiler tout √ßa. 

```Makefile
NAME = ft_display_file

SRCS = ft_display_file.c

OBJS = ${SRCS:.c=.o}

CC = gcc

CFLAGS = -Wall -Wextra -Werror

${NAME}: ${OBJS}
	${CC} -o ${NAME} ${OBJS}

all: ${NAME}

clean:
	rm -f ${OBJS}

fclean: clean
	rm -f ${NAME}

re: fclean all
```

Ici, on a juste besoin de compiler notre fichier `ft_display_file.c`, donc on a pas besoin de s'embrouiller avec des r√®gles compliqu√©es. On compile avec les flags `-Wall -Wextra -Werror` pour √™tre s√ªr de pas laisser passer d'erreurs, et on cr√©e des r√®gles `clean`, `fclean` et `re` pour nettoyer les fichiers objets et le binaire. 



1. `#define BUF_SIZE 4096` : Ici, 4096 c'est juste une taille de buffer qu'on a choisie pour lire notre fichier. Pourquoi 4096 ? Parce que c'est une taille assez courante pour un buffer, c'est souvent une bonne taille pour des raisons de performance. Mais franchement, t'aurais pu mettre une autre taille, √ßa changerait pas grand-chose. C'est juste un choix.

2. `fd = open(filename, O_RDONLY);` : L√†, on utilise la fonction `open` pour ouvrir notre fichier. Le `O_RDONLY` c'est pour dire qu'on veut ouvrir le fichier en mode "read only", c'est-√†-dire qu'on a juste le droit de le lire, pas de l'√©crire. La fonction `open` renvoie un file descriptor, c'est un genre de num√©ro qui identifie le fichier qu'on a ouvert. On stocke ce num√©ro dans `fd`.

3. Pourquoi `argc` doit √™tre √©gal √† 2 ? Parce que quand tu lances ton programme, le premier argument (`argv[0]`) c'est le nom de ton programme. Donc si tu veux donner un fichier en argument √† ton programme, il doit y avoir deux arguments en tout : le nom du programme, et le nom du fichier. Donc `argc` (qui compte le nombre d'arguments) doit √™tre √©gal √† 2. Si `argc` est inf√©rieur √† 2, √ßa veut dire qu'il manque le nom du fichier. Si `argc` est sup√©rieur √† 2, √ßa veut dire qu'il y a trop d'arguments.

 Imaginons que tu as un programme qui s'appelle `ft_display_file` et que tu veux lire un fichier qui s'appelle `test.txt`. Tu vas lancer ton programme dans ton terminal comme √ßa :

```bash
./ft_display_file test.txt
```

Ici, `./ft_display_file` c'est `argv[0]` (le nom du programme) et `test.txt` c'est `argv[1]` (le nom du fichier que tu veux lire).

Maintenant, imagine qu'on a un bout de code dans notre programme qui ressemble √† √ßa :

```c
printf("Nom du programme : %s\n", argv[0]);
printf("Nom du fichier : %s\n", argv[1]);
```

Si tu lances ton programme comme je t'ai montr√© au-dessus, √ßa va afficher :

```bash
Nom du programme : ./ft_display_file
Nom du fichier : test.txt
```

Donc voil√†, en gros c'est comme √ßa que √ßa marche. J'esp√®re que c'est plus clair pour toi maintenant, mon gars ! üòéüëå


## Exercice 01 : cat
Dans cet exercice, tu dois cr√©er un programme qui fait le m√™me boulot que la commande `cat` du syst√®me. Si tu connais pas `cat`, √ßa sert √† afficher le contenu des fichiers qu'on lui donne en param√®tre. Si t'as pas de fichier en param√®tre, `cat` lit l'entr√©e standard, c'est-√†-dire ce que tu tapes au clavier.

Alors pour cet exercice, tu dois rendre un Makefile et les fichiers de ton programme. T'as le droit d'utiliser les fonctions `close`, `open`, `read`, `write`, `strerror` et `basename`. 

Ton Makefile, il doit avoir une r√®gle `all`, une r√®gle `clean` et une r√®gle `fclean`. T'as le droit d'utiliser la variable `errno`. 

Et petit d√©tail technique, tu peux pas utiliser `malloc`, donc tu peux faire l'exercice juste avec un tableau de taille fixe. C'est un peu comme si t'avais un cahier avec un nombre de pages fixe pour √©crire ton programme, tu peux pas rajouter de pages.

Allez, on attaque le code:

```c
#include <fcntl.h>
#include <unistd.h>

#define BUF_SIZE 4096  // Taille du buffer pour la lecture du fichier

void	ft_putstr(char *str)  // Fonction pour afficher une cha√Æne de caract√®res
{
	while (*str)
		write(1, str++, 1);  // On √©crit caract√®re par caract√®re
}

int	main(int argc, char **argv)  // On prend en compte les arguments donn√©s au programme
{
	int		fd;  // Descripteur de fichier
	int		i;   // Compteur pour parcourir les arguments
	char	buf[BUF_SIZE + 1];  // Buffer pour lire le fichier
	int		ret;  // Variable pour le nombre de caract√®res lus

	i = 1;  // On commence √† 1 parce que le nom du programme est √† l'index 0
	if (argc == 1)  // Si y'a pas de fichier en argument
		while ((ret = read(0, buf, BUF_SIZE)))  // On lit l'entr√©e standard
		{
			buf[ret] = '\0';  // On ajoute le caract√®re de fin de cha√Æne
			ft_putstr(buf);  // On affiche le buffer
		}
	while (i < argc)  // Pour chaque fichier donn√© en argument
	{
		fd = open(argv[i], O_RDONLY);  // On ouvre le fichier en mode lecture seulement
		while ((ret = read(fd, buf, BUF_SIZE)))  // On lit le fichier
		{
			buf[ret] = '\0';  // On ajoute le caract√®re de fin de cha√Æne
			ft_putstr(buf);  // On affiche le buffer
		}
		close(fd);  // On ferme le fichier
		i++;  // On passe au fichier suivant
	}
	return (0);
}
```

Bon l√† je vais te montrer un test que tu peux faire. Disons que t'as un fichier qui s'appelle `test.txt` et √† l'int√©rieur t'as √©crit `Salut les potos!`. Si tu tapes `./ft_cat test.txt` dans ton terminal, √ßa va afficher `Salut les potos!`.

Pour ton Makefile, √ßa pourrait ressembler √† √ßa :

```Makefile
NAME = ft_cat
SRCS = main.c ft_putstr.c
OBJS = $(SRCS:.c=.o)
FLAGS = -Wall -Wextra -Werror

all: $(NAME)

$(NAME):
	gcc $(FLAGS) -c $(SRCS)
	gcc $(FLAGS) $(OBJS) -o $(NAME)

clean:
	rm -f $(OBJS)

fclean: clean
	rm -f $(NAME)

re: fclean all
```

Dans ce Makefile, t'as plusieurs r√®gles :

- `all` : qui est la r√®gle par d√©faut et qui cr√©e ton programme.
- `clean` : qui efface tous les fichiers objets.
- `fclean` : qui efface tous les fichiers objets et le programme.
- `re` : qui ex√©cute `fclean` et `all`, donc √ßa recompile tout depuis le d√©but.

Maintenant, pour l'output, comme j'ai dit tout √† l'heure, si tu as un fichier `test.txt` avec `Salut les potos!` dedans, quand tu tapes `./ft_cat test.txt`, ton programme doit afficher `Salut les potos!`.

Et si tu n'as pas d'arguments, c'est-√†-dire que tu tapes juste `./ft_cat` et ensuite tu tapes `Wesh bien ou quoi?`, ton programme doit afficher `Wesh bien ou quoi?`.



## Exercice 02 : Tail

### Les fichiers √† cr√©er :

1. `main.c` : Le fichier principal qui va utiliser la fonction `ft_tail`.
2. `ft_tail.c` : Ce fichier va contenir la logique principale pour imiter la commande `tail`.
3. `Makefile` : Comme toujours, on a besoin d'un Makefile pour compiler tout √ßa.
4. `ft.h` : Un fichier header pour d√©clarer les fonctions et les constantes dont on a besoin.

### Les √©tapes √† suivre :

1. On commence par cr√©er le `main.c`. Ici, on va juste v√©rifier qu'on a le bon nombre d'arguments, puis on va appeler `ft_tail` avec les arguments qu'on a re√ßus.

2. Ensuite, on passe √† `ft_tail.c`. L√†, faut faire plusieurs choses. D'abord, faut ouvrir le fichier qu'on veut lire. Ensuite, faut utiliser `lseek()` pour aller tout √† la fin du fichier. Apr√®s, faut lire le fichier √† l'envers, caract√®re par caract√®re, jusqu'√† ce qu'on ait lu autant de caract√®res que l'option `-c` le demandait.

3. Faut pas oublier le `Makefile` aussi. Comme d'habitude, on a besoin d'une r√®gle `all` pour compiler tout √ßa, et de r√®gles `clean` et `fclean` pour nettoyer apr√®s.

4. Enfin, le `ft.h`. L√†, on d√©clare juste les fonctions et les constantes qu'on va utiliser. Rien de compliqu√©.



### main.c :

```c
#include "ft.h"

int main(int argc, char **argv)
{
    if (argc != 4) // On doit avoir exactement 4 arguments (le nom du programme, "-c", le nombre de caract√®res et le nom du fichier).
    {
        ft_putstr("Nombre d'arguments incorrect, fr√©rot !\n");
        return (1);
    }
    ft_tail(argv[3], ft_atoi(argv[2])); // On appelle ft_tail avec le nom du fichier et le nombre de caract√®res √† afficher.
    return (0);
}
```

### ft_tail.c :

```c
#include "ft.h"

void ft_tail(char *file, int nb_chars)
{
    int fd;
    int size;
    char buf[1];

    fd = open(file, O_RDONLY); // On ouvre le fichier en mode lecture.
    if (fd == -1) // Si on n'arrive pas √† ouvrir le fichier, on affiche un message d'erreur et on sort.
    {
        ft_putstr("Impossible d'ouvrir le fichier, cousin !\n");
        return ;
    }
    size = lseek(fd, 0, SEEK_END); // On se place √† la fin du fichier pour conna√Ætre sa taille.
    lseek(fd, -nb_chars, SEEK_END); // On se d√©place de nb_chars caract√®res en arri√®re √† partir de la fin du fichier.
    while (read(fd, buf, 1)) // On lit le fichier caract√®re par caract√®re et on les affiche.
        ft_putchar(buf[0]);
    close(fd); // On ferme le fichier.
}
```

### Makefile :

```makefile
all:
    gcc -Wall -Wextra -Werror -o ft_tail main.c ft_tail.c

clean:
    /bin/rm -f *.o

fclean: clean
    /bin/rm -f ft_tail

re: fclean all
```

### ft.h :

```c
#ifndef FT_H
# define FT_H

# include <unistd.h>
# include <fcntl.h>

void ft_putchar(char c);
void ft_putstr(char *str);
int ft_atoi(char *str);
void ft_tail(char *file, int nb_chars);

#endif
```

Ici, `ft_atoi` est une fonction qui convertit une cha√Æne de caract√®res en un nombre entier. Elle est utilis√©e ici pour convertir l'argument repr√©sentant le nombre de caract√®res √† afficher en un v√©ritable nombre entier. üßê

Maintenant, imagine que tu as un fichier `test.txt` avec le contenu suivant :

```
Wesh, wesh, cousin !
Comment √ßa va ?
```

Si tu ex√©cutes ton programme avec la commande `./ft_tail -c 10 test.txt`, tu devrais voir afficher : 

```
 ?
√ßa va ?
```

C'est les 10 derniers caract√®res du fichier, tu vois ? Voil√†, tu as ton `tail` √† toi, fr√©rot ! üöÄüí•

##USER:
bon je te le redis tu recommences tout tu me commentes le code tu met un beau titre en md , tu explqiues tout , tu teste le code et tu montres l'output c'est pas compliqu√©

##ASSISTANT:
Wesh, pas de souci mon fr√©rot, j'vais te d√©briefer √ßa bien comme il faut !

## Exercice 03: Hexdump

L'objectif ici, c'est de cr√©er un programme qui va prendre en argument un nom de fichier, et qui va afficher le contenu de ce fichier en hexad√©cimal, un peu comme la commande `hexdump -C` du syst√®me. üîçüíª

L'id√©e g√©n√©rale, c'est qu'on va lire le fichier 16 octets par 16 octets, et chaque fois, on affiche l'offset (la position dans le fichier), le contenu en hexa, et le contenu en ASCII si possible.

### Le code, √©tape par √©tape

Allez, on commence par le d√©but : le fichier `ft_hexdump.c`.

```c
#include "ft.h"

void print_hexa(unsigned char c)
{
    char *hexa;

    hexa = "0123456789abcdef";
    ft_putchar(hexa[c / 16]);
    ft_putchar(hexa[c % 16]);
}
```

La fonction `print_hexa` ici sert √† afficher un caract√®re en hexad√©cimal. Pour √ßa, on divise le caract√®re par 16 pour avoir le premier chiffre, et on prend le reste de la division par 16 pour avoir le deuxi√®me chiffre.

```c
void print_content_line(unsigned char *buf, int size)
{
    int i;

    i = 0;
    while (i < 16)
    {
        if (i < size)
            print_hexa(buf[i]);
        else
            ft_putstr("  ");
        if (i % 2)
            ft_putchar(' ');
        i++;
    }
    i = 0;
    while (i < size)
    {
        ft_putchar((buf[i] > 31 && buf[i] < 127) ? buf[i] : '.');
        i++;
    }
    ft_putchar('\n');
}
```

Cette fonction `print_content_line` va afficher une ligne de contenu. On lui passe un buffer de 16 octets (qui contient le contenu √† afficher) et la taille r√©elle du contenu. En fait, on affiche d'abord le contenu en hexa (avec des espaces pour arriver √† 16 octets), et ensuite on affiche le contenu en ASCII quand c'est possible, sinon on met un point.

```c
void print_offset(int offset)
{
    char *hexa;
    int pos;

    hexa = "0123456789abcdef";
    pos = 7;
    while (pos >= 0)
    {
        ft_putchar(hexa[(offset >> (pos * 4)) & 0xf]);
        pos--;
    }
    ft_putchar(':');
    ft_putchar(' ');
}
```

La fonction `print_offset` sert √† afficher la position dans le fichier. Pour √ßa, on utilise un d√©calage de bits pour r√©cup√©rer chaque chiffre de l'offset.

```c
void ft_hexdump(char *filename)
{
    int fd;
    int size;
    unsigned char buf[16];
    int offset;

    fd = open(filename, O_RDONLY);
    if (fd == -1)
    {
        ft_putstr("Error while opening file\n");
        return ;
    }
    offset = 0;
    while ((size = read(fd, buf, 16)))
    {
        print_offset(offset);
        print_content_line(buf, size);
        offset += 16;
    }
    close(fd);
}
```


La fonction `ft_hexdump` ici est notre principal, c'est elle qui orchestre tout le bazar. D'abord, elle ouvre le fichier, et si y'a une embrouille (si `open` renvoie -1), elle balance un message d'erreur et elle se casse direct. 

Ensuite, tant qu'elle arrive √† lire des trucs dans le fichier (c'est-√†-dire tant que `read` renvoie pas 0), elle affiche l'offset, elle affiche le contenu de la ligne, et elle avance l'offset de 16. 

Quand y'a plus rien √† lire, elle ferme le fichier et c'est fini, rideau, on rentre √† la maison.

```c
int main(int argc, char **argv)
{
    if (argc != 2)
    {
        ft_putstr("Error: wrong number of arguments\n");
        return (1);
    }
    ft_hexdump(argv[1]);
    return (0);
}
```

La fonction `main` ici, c'est la premi√®re qui est appel√©e quand on lance le programme. Elle v√©rifie qu'on a bien donn√© un nom de fichier en argument, et si c'est bon, elle appelle `ft_hexdump` avec ce nom. Si y'a pas le bon nombre d'arguments, elle affiche un message d'erreur et elle se casse.

### Le Makefile

Allez, on passe au Makefile maintenant, mon pote. 

```makefile
CC = gcc
CFLAGS = -Wall -Wextra -Werror
NAME = ft_hexdump
SRCS = ft_hexdump.c
OBJS = $(SRCS:.c=.o)

all: $(NAME)

$(NAME): $(OBJS)
    $(CC) $(CFLAGS) -o $(NAME) $(OBJS)

clean:
    rm -f $(OBJS)

fclean: clean
    rm -f $(NAME)

re: fclean all

.PHONY: all clean fclean re
```

C'est un Makefile assez classique. On compile chaque fichier `.c` en fichier `.o`, et ensuite on assemble tout √ßa en un seul programme. Les r√®gles `clean`, `fclean` et `re` servent √† nettoyer les fichiers compil√©s et √† recompiler tout depuis le d√©but.

### L'output

Et maintenant, le moment tant attendu : l'output ! 

Imagine que t'as un fichier `test.txt` avec dedans "Hello, World!". Si tu lances `./ft_hexdump test.txt`, √ßa va te donner un truc dans le genre :

```bash
00000000: 4865 6c6c 6f2c 2057 6f72 6c64 210a       Hello, World!.
```

Et voil√†, c'est √ßa le boulot de `ft_hexdump` ! Tu vois, √ßa fait pas mal de boulot, mais en vrai c'est pas bien compliqu√©. Si t'as des questions, h√©site pas √† demander, fr√©rot ! üöÄüí•
