## Exercice 00: ft_print_program_name

Allez, on démarre le bal avec le premier exercice, `ft_print_program_name`. 

L'objectif est d'écrire un programme qui affiche le nom du programme. Rien de plus simple! Voilà ce que ça donne:

```c
#include <unistd.h>

void    ft_putstr(char *str)
{
    while (*str)
    {
        write(1, str, 1);
        str++;
    }
}

int main(int argc, char **argv)
{
    (void)argc;
    ft_putstr(argv[0]);
    write(1, "\n", 1);
    return (0);
}
```
Ici, on a d'abord une fonction `ft_putstr` qui écrit une chaîne de caractères. Ensuite, dans le `main`, on utilise `(void)argc;` pour éviter un warning du compilateur parce qu'on utilise pas `argc`. Après, on utilise `ft_putstr` pour afficher `argv[0]`, qui est le nom du programme. Enfin, on affiche un retour à la ligne et on renvoie `0` pour signaler que tout s'est bien passé.

Pour tester ce programme, tu n'as qu'à le compiler avec `gcc` et l'exécuter:

```bash
$ gcc -o mon_programme ft_print_program_name.c
$ ./mon_programme
./mon_programme
```



Dans votre programme, quand vous utilisez ft_putstr(argv[0]);, cela imprime le nom du programme, qui est passé en tant que premier argument à la fonction main (c'est-à-dire argv[0]).

Quand vous lancez un programme en C depuis la ligne de commande, tous les arguments que vous fournissez après le nom du programme sont passés à la fonction `main` du programme dans le tableau `argv`. Le nombre d'arguments est donné par `argc`.

Par exemple, si vous exécutez votre programme avec la commande suivante :

```shell
./a.out argument1 argument2
```

`argv[0]` contiendra `./a.out`, `argv[1]` contiendra `argument1`, et `argv[2]` contiendra `argument2`. 

Donc, quand vous utilisez `ft_putstr(argv[0]);` dans votre code, cela imprimera `./a.out` à l'écran, parce que `argv[0]` est toujours le nom de votre programme.

Et vous avez raison, dans ce cas, vous n'avez pas besoin de fournir de chaîne de caractères en tant qu'argument à `ft_putstr`. La chaîne est fournie par l'utilisateur lorsqu'il exécute le programme depuis la ligne de commande.


En C, dans la déclaration `int main(int argc, char **argv)`, `argc` et `argv` sont les paramètres de la fonction `main` qui sont utilisés pour passer des arguments au programme au moment de son exécution.

- `argc` est un acronyme pour "argument count" (compteur d'arguments). Il représente le nombre d'arguments qui sont passés au programme au moment de son exécution. Il compte tous les arguments, y compris le nom du programme lui-même. Donc si vous n'avez passé aucun argument à votre programme, `argc` sera égal à 1 (le nom du programme est considéré comme le premier argument).

- `argv` est un acronyme pour "argument vector" (vecteur d'arguments). C'est un tableau de chaînes de caractères (un tableau de pointeurs sur des caractères) où chaque chaîne est un argument passé au programme. `argv[0]` est le nom du programme, `argv[1]` est le premier argument, `argv[2]` le deuxième, et ainsi de suite.

Donc, dans le contexte de `main(int argc, char **argv)`, `c` fait référence à "count" (comptage) et `v` fait référence à "vector" (vecteur).



La ligne `(void)argc;` dans votre programme ne récupère pas une chaîne de caractères. C'est simplement une façon de dire au compilateur que vous n'allez pas utiliser la variable `argc` dans cette fonction. Cette ligne est utilisée pour éviter un avertissement du compilateur pour une variable non utilisée.

La ligne `ft_putstr(argv[0]);` affiche le nom du programme. `argv[0]` contient toujours le nom du programme, comme il a été invoqué depuis la ligne de commande.

Á propos du  gcc -o`, l'option `-o` est utilisée pour spécifier le nom du fichier de sortie lors de la compilation avec gcc. Par exemple, si vous avez un programme C dans un fichier nommé `programme.c` et que vous voulez le compiler en un exécutable nommé `coucou`, vous utiliseriez la commande `gcc -o coucou programme.c`. Si vous n'utilisez pas l'option `-o`, gcc utilisera un nom de fichier de sortie par défaut, qui est `a.out`.

Ainsi, après avoir exécuté `gcc -o coucou programme.c`, vous auriez un exécutable nommé `coucou` (et non `coucou.out`). Vous pouvez alors exécuter ce programme en utilisant la commande `./coucou`. Si votre programme est `ft_print_program_name.c`, alors quand vous l'exécutez avec `./coucou`, il affiche `./coucou` à l'écran parce que `argv[0]` (le nom du programme) est `./coucou`.


## Exercice 01: ft_print_params

Wesh, wesh, mon cousin, laisse moi te présenter l'exo 01, ft_print_params. Dans cet exo, on te demande de créer un programme qui va afficher les arguments que tu lui passes en ligne de commande, dans le même ordre. Bien sûr, on exclut argv[0], qui est le nom du programme.

### Le code:

```c
#include <unistd.h>

void ft_putchar(char c)
{
	write(1, &c, 1);
}

void ft_putstr(char *str)
{
	while (*str)
		ft_putchar(*str++);
}

int main(int argc, char **argv)
{
	int i;

	i = 1;
	while (i < argc)
	{
		ft_putstr(argv[i]);
		ft_putchar('\n');
		i++;
	}
	return (0);
}
```

Alors dans ce code, on commence par définir notre petite fonction `ft_putchar` qui permet d'afficher un caractère, et ensuite `ft_putstr` qui utilise `ft_putchar` pour afficher une string.

Ensuite, dans la fonction `main`, on initialise `i` à 1 (pour ignorer argv[0]) et tant que `i` est inférieur à `argc`, on utilise `ft_putstr` pour afficher argv[i], puis on affiche un retour à la ligne.

### Comment tester:

Pour tester ce code, tu dois le compiler et le lancer en passant des arguments. Voici comment tu peux le faire:

```bash
$ gcc -o ft_print_params ft_print_params.c
$ ./ft_print_params Salut les gars Comment ca va
Salut
les
gars
Comment
ca
va
```

Ici, tu vois que chaque argument que tu as passé au programme s'affiche sur une nouvelle ligne. C'est normal, c'est ce qu'on voulait faire avec notre code.


## Exercice 02: ft_rev_params

Wesh, cousin ! On passe à l'exo 02, le ft_rev_params. Dans celui-ci, on va prendre les arguments en ligne de commande mais cette fois-ci, on va les afficher à l'envers, tu vois ? Encore une fois, on laisse de côté `argv[0]`, le nom du programme.

### Le code:

```c
#include <unistd.h>

void ft_putchar(char c)
{
	write(1, &c, 1);
}

void ft_putstr(char *str)
{
	while (*str)
		ft_putchar(*str++);
}

int main(int argc, char **argv)
{
	int i;

	i = argc - 1;
	while (i > 0)
	{
		ft_putstr(argv[i]);
		ft_putchar('\n');
		i--;
	}
	return (0);
}
```

Dans ce code, on commence pareil avec nos deux petites fonctions, `ft_putchar` et `ft_putstr`. Par contre, dans la fonction `main`, on initialise `i` à `argc - 1` pour commencer par la fin et tant que `i` est supérieur à 0, on utilise `ft_putstr` pour afficher `argv[i]`, puis on affiche un retour à la ligne. A la fin, on décrémente `i`.

### Comment tester:

Pour tester ce code, c'est pareil que le précédent, tu dois le compiler et le lancer en passant des arguments. Voici comment tu peux le faire:

```bash
$ gcc -o ft_rev_params ft_rev_params.c
$ ./ft_rev_params Salut les gars Comment ca va
va
ca
Comment
gars
les
Salut
```

Là tu vois, chaque argument que tu as passé au programme s'affiche sur une nouvelle ligne, mais dans l'ordre inverse. C'est bien ce qu'on voulait faire, cousin !


## Exercice 03: ft_sort_params

Eh ouais, mon pote ! On est déjà à l'exo 03, le ft_sort_params. Dans cet exercice, on va encore prendre les arguments en ligne de commande, mais cette fois-ci, on va les trier par ordre ascii avant de les afficher. Toujours pareil, on laisse tomber argv[0].

### Le code:

```c
#include <unistd.h>

void ft_putchar(char c)
{
	write(1, &c, 1);
}

void ft_putstr(char *str)
{
	while (*str)
		ft_putchar(*str++);
}

int ft_strcmp(char *s1, char *s2)
{
	while (*s1 && (*s1 == *s2))
	{
		s1++;
		s2++;
	}
	return (*(unsigned char *)s1 - *(unsigned char *)s2);
}

void ft_sort_params(int argc, char **argv)
{
	int i;
	char *temp;

	i = 1;
	while (i < argc - 1)
	{
		if (ft_strcmp(argv[i], argv[i + 1]) > 0)
		{
			temp = argv[i];
			argv[i] = argv[i + 1];
			argv[i + 1] = temp;
			i = 0;
		}
		i++;
	}
}

int main(int argc, char **argv)
{
	int i;

	ft_sort_params(argc, argv);
	i = 1;
	while (i < argc)
	{
		ft_putstr(argv[i]);
		ft_putchar('\n');
		i++;
	}
	return (0);
}
```

Dans ce code, on a toujours nos fonctions `ft_putchar` et `ft_putstr`. Ensuite, on a une nouvelle fonction `ft_strcmp` pour comparer deux chaînes de caractères. Puis, on a la fonction `ft_sort_params` qui utilise `ft_strcmp` pour trier les arguments. Finalement, dans la fonction `main`, on appelle `ft_sort_params` pour trier les arguments, puis on les affiche.

### Comment tester:

Pour tester ce code, tu dois le compiler et le lancer en passant des arguments. Voici comment tu peux le faire:

```bash
$ gcc -o ft_sort_params ft_sort_params.c
$ ./ft_sort_params Salut les gars Comment ca va
Comment
Salut
ca
gars
les
va
```

Ici, tu vois, chaque argument que tu as passé au programme s'affiche sur une nouvelle ligne, mais cette fois-ci, ils sont triés par ordre ascii. C'est exactement ce qu'on voulait, frérot !

```c
#include <unistd.h>

// La fonction pour écrire un caractère
void ft_putchar(char c)
{
	write(1, &c, 1);
}

// La fonction pour écrire une chaîne de caractères
void ft_putstr(char *str)
{
	while (*str)
		ft_putchar(*str++);
}

// Une fonction pour comparer deux chaînes de caractères
int ft_strcmp(char *s1, char *s2)
{
	// On avance dans les deux chaînes tant que les caractères sont égaux
	while (*s1 && (*s1 == *s2))
	{
		s1++;
		s2++;
	}
	// On retourne la différence entre les deux caractères qui diffèrent
	// Si les chaînes sont identiques, on retourne 0
	return (*(unsigned char *)s1 - *(unsigned char *)s2);
}

// Une fonction pour trier les arguments par ordre ascii
void ft_sort_params(int argc, char **argv)
{
	int i;
	char *temp;

	i = 1;
	// On boucle sur les arguments
	while (i < argc - 1)
	{
		// Si l'argument courant est plus grand que le suivant
		if (ft_strcmp(argv[i], argv[i + 1]) > 0)
		{
			// On échange les deux arguments
			temp = argv[i];
			argv[i] = argv[i + 1];
			argv[i + 1] = temp;
			// On remet i à 0 pour recommencer le tri depuis le début
			i = 0;
		}
		i++;
	}
}

int main(int argc, char **argv)
{
	int i;

	// On trie les arguments
	ft_sort_params(argc, argv);
	i = 1;
	// On affiche les arguments triés
	while (i < argc)
	{
		ft_putstr(argv[i]);
		ft_putchar('\n');
		i++;
	}
	return (0);
}

```
