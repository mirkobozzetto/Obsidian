## Exercice 00 : ft_iterative_factorial

Ce qu'on te demande ici, c'est de faire une fonction qui va calculer la factorielle d'un nombre. Si t'as oubli√©, la factorielle c'est quand tu multiplies un nombre par tous les nombres inf√©rieurs √† lui jusqu'√† 1. Par exemple, la factorielle de 5, √ßa fait 5 * 4 * 3 * 2 * 1 = 120. Mais attention, la factorielle de 0, c'est 1, c'est un cas sp√©cial.

Voici comment tu peux √©crire cette fonction en C :

```c
int ft_iterative_factorial(int nb)
{
	int result;

	if (nb < 0)
		return (0);
	if (nb == 0)
		return (1);
	result = 1;
	while (nb > 1)
	{
		result *= nb;
		nb--;
	}
	return (result);
}
```

Bon, ici, si le nombre est n√©gatif, on retourne 0 direct parce qu'on peut pas faire la factorielle d'un nombre n√©gatif, c'est pas logique. Si le nombre est 0, on retourne 1 parce que la factorielle de 0 c'est 1, c'est comme √ßa. Sinon, on fait une boucle qui va multiplier le r√©sultat par le nombre, et ensuite on diminue le nombre de 1, et on continue comme √ßa jusqu'√† ce que le nombre soit 1.

Pour tester ce truc, tu peux faire une petite fonction main qui appelle ta fonction avec diff√©rents nombres et qui affiche le r√©sultat. Voil√† comment tu peux faire :

```c
#include <stdio.h>

int main()
{
	int i;
	
	i = -1;
	while (i < 10)
	{
		printf("Factorielle de %d = %d\n", i, ft_iterative_factorial(i));
		i++;
	}
	return (0);
}
```

Cette fonction main va appeler ta fonction ft_iterative_factorial avec tous les nombres de -1 √† 9 et afficher le r√©sultat. Tu peux voir comment √ßa se passe et v√©rifier si tout est bon.

ou plus simple

```c
#include <stdio.h>

int main(void)
{
    int nb = 5;
    printf("La factorielle de %d est %d\n", nb, ft_iterative_factorial(nb));
    return 0;
}

```


## Exercice 01 : ft_recursive_factorial

	L√†, c'est la m√™me chose que l'exercice pr√©c√©dent, mais on va utiliser la r√©cursivit√©. C'est une technique o√π une fonction s'appelle elle-m√™me. On va partir du nombre et multiplier par la factorielle du nombre moins un, et on continue comme √ßa jusqu'√† arriver √† 1.

Tiens, regarde comment on fait :

```c
int ft_recursive_factorial(int nb)
{
	if (nb < 0)
		return (0);
	if (nb <= 1)
		return (1);
	return (nb * ft_recursive_factorial(nb - 1));
}
```

Ici, si le nombre est n√©gatif, on retourne 0 direct. Si le nombre est 0 ou 1, on retourne 1. Sinon, on retourne le nombre multipli√© par la factorielle du nombre moins un, et on continue comme √ßa jusqu'√† ce qu'on arrive √† 1.

Pour tester ce bazar, tu peux utiliser le m√™me programme que tout √† l'heure, tu changes juste le nom de la fonction pour appeler ft_recursive_factorial √† la place de ft_iterative_factorial.

```c
	return (nb * ft_recursive_factorial(nb - 1));
```

Alors, cette ligne, c'est du pur jus de r√©cursivit√©. 

Disons qu't'as un nombre, genre 5. C'que fait cette ligne, c'est qu'elle va multiplier 5 par la factorielle de 4 (parce que 5-1 √ßa fait 4, tu suis?). Mais comment on calcule la factorielle de 4 ? Ben c'est simple, on utilise la m√™me fonction, ft_recursive_factorial. Donc on va multiplier 4 par la factorielle de 3. Et on continue comme √ßa jusqu'√† arriver √† 1. √Ä ce moment-l√†, la fonction renvoie 1 (parce que la factorielle de 1, c'est 1), et on remonte tout le tas de multiplications qu'on a fait.

En gros, si tu veux la factorielle de 5, tu fais 5 * la factorielle de 4. Pour avoir la factorielle de 4, tu fais 4 * la factorielle de 3. Et ainsi de suite jusqu'√† 1. C'est pour √ßa qu'on dit que la fonction s'appelle elle-m√™me : √† chaque fois, elle fait une multiplication, et pour savoir par quoi multiplier, elle doit calculer la factorielle du nombre pr√©c√©dent.

J'sais, √ßa peut para√Ætre un peu tordu la premi√®re fois qu'on le voit, mais une fois que t'as pig√© le truc, c'est hyper puissant. C'est comme si t'avais une arm√©e de clones qui bossent pour toi, et chaque clone fait une petite partie du boulot. üîÑüí™


On va juste cr√©er un petit programme principal (`main`) pour appeler notre fonction `ft_recursive_factorial`. 

Voici ce que √ßa pourrait donner :

```c
#include <stdio.h>

int	main(void)
{
	int nb;

	nb = 5;
	printf("La factorielle de %d est %d\n", nb, ft_recursive_factorial(nb));
	return (0);
}
```

Dans ce programme, on initialise `nb` √† 5, puis on appelle notre fonction `ft_recursive_factorial` avec `nb` comme argument, et on affiche le r√©sultat. 

Si tu lances √ßa, tu devrais voir quelque chose comme :

```
La factorielle de 5 est 120
```


## Exercice 02 : ft_iterative_power

Wesh, cousin, tu veux g√©rer la puissance d'un nombre de mani√®re it√©rative, hein ? Pas de probl√®me, on est l√† pour √ßa. T'as pas besoin de g√©rer les d√©bordements ici. On consid√®re aussi que 0 √† la puissance 0 donne 1. 

Voici le code qui fait l'boulot :

```c
int ft_iterative_power(int nb, int power)
{
	int result;

	if (power < 0)
		return (0);
	if (power == 0)
		return (1);
	result = 1;
	while (power--)
	{
		result *= nb;
	}
	return (result);
}
```

T'sais quoi, on peut m√™me tester √ßa. Imagine tu veux tester avec le nombre 2 √† la puissance de 3. On cr√©e un programme principal, un `main`, qui appelle notre fonction `ft_iterative_power`. Voici ce que √ßa donne :

```c
#include <stdio.h>

int main(void)
{
	int nb = 2;
	int power = 3;
	printf("La puissance de %d √† la puissance de %d est %d\n", nb, power, ft_iterative_power(nb, power));
	return 0;
}
```

Si tu lances √ßa, tu devrais voir quelque chose comme :

```
La puissance de 2 √† la puissance de 3 est 8
```

C'est la base fr√©rot, faut toujours tester ce que tu codes! C'est comme √ßa qu'on s'assure que tout fonctionne comme sur des roulettes. üëçüòéüí™



## Exercice 03 : ft_recursive_power

Bon, le but ici c'est de cr√©er une fonction r√©cursive qui renvoie une puissance d'un nombre. T'as pig√© le truc ? On se fout de si la puissance est inf√©rieure √† 0, dans ce cas, on renvoie 0. Et si on tombe sur le cas o√π 0 est √† la puissance de 0, bah on consid√®re que √ßa donne 1. Tant pis pour ceux qui sont pas d'accord. Et enfin, si t'as un d√©bordement, on s'en tape, le r√©sultat sera ind√©fini.

Voil√† le code qu'il te faut, mon pote :

```c
int ft_recursive_power(int nb, int power)
{
	if (power < 0)
		return (0);
	if (power == 0)
		return (1);
	else
		return (nb * ft_recursive_power(nb, power - 1));
}
```

T'as vu ? Pas plus compliqu√© que √ßa. En gros, ce qu'on fait c'est qu'on v√©rifie d'abord si la puissance est inf√©rieure √† 0. Si c'est le cas, c'est pas normal alors on renvoie 0. Ensuite, on checke si la puissance est √©gale √† 0. Si c'est le cas, peu importe le nombre, √ßa donne 1. Et enfin, si on est dans aucun des cas pr√©c√©dents, on multiplie le nombre par la fonction elle-m√™me mais avec la puissance diminu√©e de 1. Comme √ßa, √† chaque fois qu'on passe dans la fonction, la puissance diminue jusqu'√† arriver √† 0 et bam, √ßa renvoie 1 et on peut faire toutes les multiplications en remontant.

Pour tester tout √ßa, tu peux faire un truc du genre :

```c
#include <stdio.h>

int main(void)
{
	int nb = 3;
	int power = 4;
	printf("%d √† la puissance de %d est %d\n", nb, power, ft_recursive_power(nb, power));
	return (0);
}
```

Et l√†, si tu lances le bazar, √ßa devrait te sortir :

```
3 √† la puissance de 4 est 81
```



## Exercice 04 : ft_fibonacci

On se lance maintenant sur la suite de Fibonacci, t'as capt√© ou pas ? üßê On doit faire une fonction qui renvoie le n-i√®me √©l√©ment de la suite de Fibonacci. Le premier √©l√©ment, c'est le 0, t'as vu ? Et apr√®s √ßa roule : 0, 1, 1, 2, etc.

Si ton `index` est inf√©rieur √† 0, ta fonction doit renvoyer -1, parce que l√† c'est pas normal. Et si on a un d√©passement, bah on s'en fout, on g√®re pas √ßa.

Regarde comment c'est fait : 

```c
int ft_fibonacci(int index)
{
	if (index < 0)
		return (-1);
	if (index == 0)
		return (0);
	else if (index == 1)
		return (1);
	else
		return (ft_fibonacci(index - 1) + ft_fibonacci(index - 2));
}
```

Ici, c'est la m√™me, on v√©rifie d'abord si `index` est inf√©rieur √† 0. Si c'est le cas, on renvoie -1. Ensuite, si `index` est √©gal √† 0 ou √† 1, on renvoie respectivement 0 et 1, parce que c'est √ßa la suite de Fibonacci. Et enfin, si `index` est plus grand que 1, on renvoie la somme des deux termes pr√©c√©dents dans la suite, donc on fait deux appels r√©cursifs, un avec `index - 1` et un avec `index - 2`.

Maintenant pour tester ce bousin, fais comme √ßa :

```c
#include <stdio.h>

int main(void)
{
	int index = 9;
	printf("Le %d-i√®me terme de la suite de Fibonacci est %d\n", index, ft_fibonacci(index));
	return (0);
}
```


Quand on parle de la suite de Fibonacci et qu'on commence √† l'index 0, √ßa donne √ßa :

- A l'index 0, on a le nombre 0.
- A l'index 1, on a le nombre 1.
- A l'index 2, on a 0 + 1, soit 1.
- A l'index 3, on a 1 + 1, soit 2.
- A l'index 4, on a 1 + 2, soit 3.
- A l'index 5, on a 2 + 3, soit 5.
- A l'index 6, on a 3 + 5, soit 8.
- A l'index 7, on a 5 + 8, soit 13.
- A l'index 8, on a 8 + 13, soit 21.
- Et enfin, √† l'index 9, on a 13 + 21, soit 34.


Donc ouais, l'index 9 correspond bien au nombre 34 dans la suite de Fibonacci. T'as tout pig√©! üéâ


Et l√†, tu devrais voir appara√Ætre :

```
Le 9-i√®me terme de la suite de Fibonacci est 34
```





## Exercice 05: ft_sqrt

Le but de cette t√¢che est de cr√©er une fonction qui renvoie la racine carr√©e enti√®re d'un nombre. C'est-√†-dire que si la racine carr√©e de ce nombre est un chiffre entier, alors on renvoie cette racine carr√©e. Si c'est pas un chiffre entier, alors on renvoie 0. 

La signature de la fonction, c'est √† dire son prototype, est : `int ft_sqrt(int nb);`

Tu te dis s√ªrement : "Wesh, comment je fais √ßa ?"

Pas de panique, je vais t'expliquer.

Voil√† comment tu pourrais √©crire cette fonction en C :

```c
int ft_sqrt(int nb)
{
    int i;

    if (nb < 0)
        return (0);
    i = 0;
    while (i * i < nb)
        i++;
    if (i * i == nb)
        return (i);
    else
        return (0);
}
```

Alors maintenant, je vais te montrer ce que √ßa fait ligne par ligne.

- `int i;` : Ici, on d√©clare une variable enti√®re `i` qui va servir de compteur.
- `if (nb < 0) return (0);` : Si le nombre donn√© est n√©gatif, alors la racine carr√©e n'est pas d√©finie, donc on renvoie 0 direct.
- `i = 0;` : On initialise notre compteur `i` √† 0.
- `while (i * i < nb) i++;` : Ici, on va faire augmenter notre compteur `i` jusqu'√† ce que `i * i` soit au moins √©gal √† `nb`. C'est l'√©quivalent de chercher la racine carr√©e de `nb`.
- `if (i * i == nb) return (i);` : Si `i * i` est √©gal √† `nb`, alors `i` est bien la racine carr√©e de `nb`, et on renvoie `i`.
- `else return (0);` : Sinon, √ßa veut dire que `i * i` est sup√©rieur √† `nb`, et donc que la racine carr√©e de `nb` n'est pas un entier. Du coup, on renvoie 0.

Et voil√†, tu as ta fonction pour calculer la racine carr√©e enti√®re. 

Pour la tester, tu peux utiliser ce code :

```c
#include <stdio.h>

int main()
{
    int number = 16;
    printf("La racine carr√©e de %d est : %d\n", number, ft_sqrt(number));
    return (0);
}
```

Ce code va simplement appeler ta fonction avec le nombre 16 et afficher le r√©sultat. Si ton code est bon, √ßa devrait afficher : `La racine carr√©e de 16 est : 4`.




## Exercice 06 : ft_is_prime

L√†, ils te demandent de cr√©er une fonction qui d√©termine si un nombre est premier ou pas. Pour rappel, un nombre premier, c'est un nombre qui a exactement deux diviseurs : 1 et lui-m√™me.

Alors on va s'y mettre cousin. Voici ce que √ßa pourrait donner :

```c
int ft_is_prime(int nb)
{
    int i;

    if (nb <= 1)
        return (0);
    i = 2;
    while (i * i <= nb)
    {
        if (nb % i == 0)
            return (0);
        i++;
    }
    return (1);
}
```

Alors l√†, je t'explique ce qui se passe :

- `int i;` : On d√©clare une variable `i` qui va nous servir de compteur.
- `if (nb <= 1) return (0);` : Si le nombre donn√© est inf√©rieur ou √©gal √† 1, alors il n'est pas premier. On renvoie 0 direct.
- `i = 2;` : On commence notre compteur √† 2, car tous les nombres sont divisibles par 1, donc √ßa sert √† rien de v√©rifier √ßa.
- `while (i * i <= nb)` : On fait une boucle jusqu'√† ce que le carr√© de `i` soit plus grand que `nb`. C'est une optimisation, parce qu'au-del√† de la racine carr√©e de `nb`, y a pas besoin de v√©rifier, √ßa peut pas √™tre un diviseur.
- `if (nb % i == 0) return (0);` : Si `nb` est divisible par `i`, alors `nb` n'est pas un nombre premier. On renvoie 0 direct.
- `i++;` : On augmente `i` √† chaque tour de boucle.
- `return (1);` : Si on a pas trouv√© de diviseur jusqu'ici, alors `nb` est bien un nombre premier. On renvoie 1.

Pour tester ce bazar, tu peux faire √ßa :

```c
#include <stdio.h>

int main()
{
    int number = 17;
    if (ft_is_prime(number))
        printf("%d est un nombre premier\n", number);
    else
        printf("%d n'est pas un nombre premier\n", number);
    return (0);
}
```

Ce code va simplement appeler ta fonction avec le nombre 17 et afficher si c'est un nombre premier ou pas. Si ton code est bon, √ßa devrait afficher : `17 est un nombre premier`.

Si tu veux tester avec d'autres nombres, tu peux juste changer le `17` dans le `main`.




## Exercice 07 : ft_find_next_prime

Maintenant, ils te demandent de cr√©er une fonction qui va trouver le nombre premier qui vient tout de suite apr√®s le nombre que tu donnes. Alors, on va r√©utiliser notre fonction `ft_is_prime` de tout √† l'heure, tu vois.

Voil√† comment on peut le faire :

```c
int ft_find_next_prime(int nb)
{
    if (nb <= 2)
        return (2);
    while (!ft_is_prime(nb))
        nb++;
    return (nb);
}
```

Alors l√†, je t'explique ce qui se passe :

- `if (nb <= 2) return (2);` : Si le nombre donn√© est inf√©rieur ou √©gal √† 2, alors le prochain nombre premier est 2. On renvoie 2 direct.
- `while (!ft_is_prime(nb)) nb++;` : On fait une boucle jusqu'√† ce qu'on trouve un nombre premier. √Ä chaque tour de boucle, on incr√©mente `nb` et on v√©rifie si c'est un nombre premier avec notre fonction `ft_is_prime`.
- `return (nb);` : Une fois qu'on a trouv√© un nombre premier, on le renvoie.

Et pour tester √ßa, voici un petit `main` :

```c
#include <stdio.h>

int main()
{
    int number = 17;
    int next_prime = ft_find_next_prime(number);
    printf("Le nombre premier qui vient apr√®s %d est %d\n", number, next_prime);
    return (0);
}
```

Ce code va simplement appeler ta fonction avec le nombre 17 et afficher le nombre premier qui vient apr√®s. Si ton code est bon, √ßa devrait afficher : `Le nombre premier qui vient apr√®s 17 est 19`.



## Exercice 08 : Les dix dames

Alors l√† mon pote, on a un gros morceau. Le probl√®me des dames, c'est un classique en programmation. Le but, c'est de placer dix dames sur un √©chiquier de 10x10 sans qu'elles ne puissent s'attaquer. 

Je te montre comment on peut faire √ßa, mais accroche-toi, √ßa risque d'√™tre un peu chaud :

```c
#include <unistd.h>

int g_board[10];
int g_count;

void ft_putchar(char c)
{
    write(1, &c, 1);
}

void print_solution()
{
    int y;

    for (y = 0; y < 10; y++)
    {
        ft_putchar(g_board[y] + '0');
    }
    ft_putchar('\n');
    g_count++;
}

int is_safe(int y, int x)
{
    int i;

    i = -1;
    while (++i < y)
        if (g_board[i] == x || g_board[i] - i == x - y || g_board[i] + i == x + y)
            return (0);
    return (1);
}

void solve(int y)
{
    int x;

    x = -1;
    while (++x < 10)
    {
        if (is_safe(y, x))
        {
            g_board[y] = x;
            if (y == 9)
                print_solution();
            else
                solve(y + 1);
        }
    }
}

int ft_ten_queens_puzzle(void)
{
    g_count = 0;
    solve(0);
    return (g_count);
}
```

Et voici comment tu peux tester √ßa avec un `main` :

```c
#include <stdio.h>

int main()
{
    int count = ft_ten_queens_puzzle();
    printf("Il y a %d solutions au probl√®me des 10 dames.\n", count);
    return (0);
}
```

Ce code va simplement appeler ta fonction et afficher le nombre de solutions qu'elle a trouv√©. Si ton code est bon, √ßa devrait afficher : `Il y a 724 solutions au probl√®me des 10 dames.`

#### D√©tail √©tape par √©tape !

On commence avec ces deux variables globales:
```c
int g_board[10];
int g_count;
```
`g_board[10]` est un tableau qui va contenir l'√©tat actuel de l'√©chiquier, et `g_count` va compter combien de solutions on a trouv√©es.

Ensuite, on a une fonction toute simple pour √©crire un caract√®re √† l'√©cran:
```c
void ft_putchar(char c)
{
    write(1, &c, 1);
}
```
Rien de ouf l√†, c'est du basique.

Puis, on a cette fonction `print_solution()`:
```c
void print_solution()
{
    int y;

    for (y = 0; y < 10; y++)
    {
        ft_putchar(g_board[y] + '0');
    }
    ft_putchar('\n');
    g_count++;
}
```
Elle va juste balancer √† l'√©cran l'√©tat actuel de l'√©chiquier, en ajoutant `'0'` √† chaque case pour que √ßa s'affiche en chiffres et pas en charact√®res bizarres, tu vois? √Ä la fin, elle ajoute 1 √† `g_count` parce qu'on a trouv√© une solution.

Apr√®s, on a `is_safe(int y, int x)`:
```c
int is_safe(int y, int x)
{
    int i;

    i = -1;
    while (++i < y)
        if (g_board[i] == x || g_board[i] - i == x - y || g_board[i] + i == x + y)
            return (0);
    return (1);
}
```
Celle-l√†, elle sert √† checker si on peut placer une dame √† la position `(y, x)` sans qu'elle se fasse bouffer. Pour √ßa, elle v√©rifie trois trucs :
1. Est-ce qu'il y a d√©j√† une dame sur la m√™me colonne ? (`g_board[i] == x`)
2. Est-ce qu'il y a une dame sur la diagonale de gauche ? (`g_board[i] - i == x - y`)
3. Est-ce qu'il y a une dame sur la diagonale de droite ? (`g_board[i] + i == x + y`)

Si une des trois conditions est vraie, on peut pas mettre de dame ici, donc on renvoie `0`. Sinon, on renvoie `1`.

Ensuite, on a `solve(int y)`:
```c
void solve(int y)
{
    int x;

    x = -1;
    while (++x < 10)
    {
        if (is_safe(y, x))
        {
            g_board[y] = x;
            if (y == 9)
                print_solution();
            else
                solve(y + 1);
        }
    }
}
```
C'est l√† que se passe tout le boulot. Cette fonction va essayer de placer une dame sur chaque case de la rang√©e `y`. Si elle trouve une case s√ªre (`is_safe(y, x) == 1`), elle place la dame et passe √† la rang√©e suivante (`solve(y + 1)`). Si on est √† la derni√®re rang√©e (`y == 9`) et qu'on a r√©ussi √† placer une dame, on a trouv√© une solution, donc on l'affiche avec `print_solution()`.

Enfin, on a¬†`ft_ten_queens_puzzle()`:

```c
int ft_ten_queens_puzzle(void)
{
    g_count = 0;
    solve(0);
    return (g_count);
}
```
Ici, c'est le point de d√©part. On r√©initialise le compteur de solutions √† `0`, et on commence √† essayer de placer des dames √† partir de la premi√®re rang√©e (`solve(0)`). √Ä la fin, on renvoie le nombre total de solutions qu'on a trouv√©.

En gros, le c≈ìur de ce programme, c'est l'algo de backtracking. Chaque fois qu'on place une dame, on passe √† la rang√©e suivante. Si on arrive √† un point o√π on peut pas placer de dame, on remonte d'une rang√©e, on bouge la dame qu'on avait plac√©e et on r√©essaye. On continue comme √ßa jusqu'√† qu'on ait essay√© toutes les combinaisons possibles.

Alors, pour tester le bousin, tu vas l'utiliser dans une fonction `main` comme √ßa:

```c
#include <stdio.h>

int ft_ten_queens_puzzle(void);

int main()
{
    printf("%d\n", ft_ten_queens_puzzle());
    return (0);
}
```
Avec cette fonction `main`, tu vas voir affich√©es toutes les solutions possibles, et √† la fin, le nombre total de solutions. C'est cool, non? üòé