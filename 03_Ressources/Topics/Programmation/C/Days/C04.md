## Exercice 00 : ft_strlen

Ici, on doit cr√©er une fonction qui compte le nombre de caract√®res dans une cha√Æne de caract√®res, et qui retourne le nombre trouv√©. La fonction doit √™tre prototyp√©e comme √ßa : `int ft_strlen(char *str);`.

Pour faire √ßa, c'est pas sorcier. On fait une boucle qui parcourt la cha√Æne de caract√®res jusqu'√† ce qu'elle trouve le caract√®re de fin de cha√Æne (qui est '\0' en C). √Ä chaque fois qu'on passe sur un caract√®re, on incr√©mente un compteur. Et c'est ce compteur qu'on retourne √† la fin. 

Regarde un peu comment on fait √ßa :

```c
int ft_strlen(char *str)
{
	int i;

	i = 0;
	while (str[i] != '\0')
	{
		i++;
	}
	return (i);
}
```

Facile, non ? Pour tester cette fonction, on peut l'int√©grer dans une fonction main comme √ßa :

```c
#include <stdio.h>

int main(void)
{
	char str[] = "Salut les potos!";

	printf("La longueur de la cha√Æne est : %d\n", ft_strlen(str));
	return (0);
}
```

Quand tu ex√©cutes ce programme, √ßa va afficher "La longueur de la cha√Æne est : 16", parce que "Salut les potos!" a 16 caract√®res, si on compte les espaces et le point d'exclamation.

Et voil√†, c'est tout pour le premier exercice du C04. On a cr√©√© une fonction qui compte le nombre de caract√®res dans une cha√Æne de caract√®res. C'est une fonction de base en C, mais c'est toujours utile de savoir comment elle fonctionne.


## Exercice 01 : ft_putstr

Pour cet exo, la fonction doit √™tre prototyp√©e comme √ßa : `void ft_putstr(char *str);`. Et on a le droit d'utiliser la fonction write pour le faire.

En fait, c'est plut√¥t simple. On va utiliser notre fonction ft_strlen qu'on vient de cr√©er pour conna√Ætre la longueur de la cha√Æne de caract√®res, et ensuite on utilise write pour l'afficher √† l'√©cran. Regarde :

```c
#include <unistd.h>

void ft_putstr(char *str)
{
	int len;

	len = ft_strlen(str);
	write(1, str, len);
}
```

Et voil√†, c'est tout ! Avec cette fonction, tu peux afficher n'importe quelle cha√Æne de caract√®res √† l'√©cran.

Pour tester √ßa, tu peux utiliser une fonction main comme √ßa :

```c
int main(void)
{
	char str[] = "Wesh la street !";

	ft_putstr(str);
	return (0);
}
```

Et si tu ex√©cutes √ßa, √ßa va afficher "Wesh la street !" √† l'√©cran.



## Exercice 02 : ft_putnbr

Ici, on doit √©crire une fonction qui va prendre un nombre en param√®tre et l'afficher √† l'√©cran. Il faut faire attention, parce qu'il faut pouvoir g√©rer tous les nombres possibles d'un int, m√™me les n√©gatifs. Donc on va devoir utiliser une astuce pour g√©rer √ßa.

Voici comment on peut le faire :

```c
#include <unistd.h>

void ft_putchar(char c)
{
	write(1, &c, 1);
}

void ft_putnbr(int nb)
{
	if (nb < 0)
	{
		ft_putchar('-');
		nb = -nb;
	}
	if (nb > 9)
	{
		ft_putnbr(nb / 10);
		ft_putnbr(nb % 10);
	}
	else
		ft_putchar(nb + '0');
}
```

Ici, la fonction ft_putnbr va utiliser une autre fonction, ft_putchar, pour afficher les chiffres un par un. Si le nombre est n√©gatif, on met un '-' avant et on change le signe du nombre. Ensuite, on divise le nombre par 10 pour obtenir le chiffre des dizaines, et on utilise le modulo 10 pour obtenir le chiffre des unit√©s. On r√©p√®te √ßa tant qu'il reste des chiffres √† afficher.

Pour tester √ßa, tu peux utiliser une fonction main comme √ßa :

```c
int main(void)
{
	ft_putnbr(42);
	return (0);
}
```

Et si tu ex√©cutes √ßa, √ßa va afficher "42" √† l'√©cran.

## __   ... petit rappel

L'ASCII, c'est juste une norme qui associe un num√©ro √† chaque caract√®re qu'on peut taper sur un clavier, chiffres, lettres, symboles, tout √ßa. Par exemple, le chiffre '0' a le num√©ro 48 en ASCII, '1' a le num√©ro 49, et ainsi de suite jusqu'√† '9' qui a le num√©ro 57.

Donc, dans ce code, quand on fait `nb + '0'`, en fait on ajoute le num√©ro ASCII de '0' (qui est 48) √† notre chiffre. Donc si nb = 0, on a 48 + 0 = 48, donc on affiche '0'. Si nb = 1, on a 48 + 1 = 49, donc on affiche '1', et ainsi de suite.

Pour les nombres √† plusieurs chiffres, on utilise une petite astuce avec la division et le modulo. En gros, si on a un nombre comme 123, quand on le divise par 10, on obtient 12 (on ignore le reste). Et si on fait 123 modulo 10, on obtient 3 (le reste de la division par 10). Donc en faisant `ft_putnbr(nb / 10); ft_putnbr(nb % 10);`, on affiche d'abord tous les chiffres sauf le dernier (12), puis on affiche le dernier chiffre (3). Et on fait √ßa de mani√®re r√©cursive, donc pour 12 on va afficher 1 puis 2, et pour 1 on l'affiche directement.

## ___


## Exercice 03 : ft_atoi

L√†, on doit √©crire une fonction qui convertit une cha√Æne de caract√®res en un entier. C'est comme la fonction `atoi` dans la biblioth√®que standard C.

Le code pourrait ressembler √† quelque chose comme √ßa :

```c
int	ft_atoi(char *str)
{
	int i;
	int signe;
	int nb;

	i = 0;
	signe = 1;
	nb = 0;
	while (str[i] == ' ' || (str[i] >= 9 && str[i] <= 13))
		i++;
	while (str[i] == '-' || str[i] == '+')
	{
		if (str[i] == '-')
			signe *= -1;
		i++;
	}
	while (str[i] >= '0' && str[i] <= '9')
	{
		nb = nb * 10 + str[i] - '0';
		i++;
	}
	return (signe * nb);
}
```

Bon, on va d√©composer ce code :

- Les trois premi√®res boucles while servent √† ignorer les espaces et les signes + et - au d√©but de la cha√Æne. On met √† jour le signe en fonction du nombre de signes - qu'on trouve.

- La derni√®re boucle while fait le gros du boulot : elle convertit les chiffres de la cha√Æne en nombre. On prend chaque chiffre, on le convertit en nombre en le soustrayant √† '0' (comme on a expliqu√© avant avec l'ASCII), et on l'ajoute √† notre nombre total.

Et voil√†, on a notre fonction `ft_atoi`.

Pour le tester, tu peux utiliser ce petit bout de code :

```c
int main()
{
	char str[] = "   ---+--+1234ab567";
	printf("%d\n", ft_atoi(str));
	return (0);
}
```

Tu devrais voir s'afficher -1234. Si c'est le cas, c'est que ta fonction marche nickel, fr√©rot ! ü§ò


## Exercice 04 : ft_putnbr_base

Pour cet exo, tu vas √©crire une fonction qui affiche un nombre dans le terminal dans une base donn√©e. Tu connais le principe des bases en informatique, pas vrai ? 

Comme d'hab, j'te balance d'abord le code de l'exercice et ensuite on le d√©cortique ensemble. Fais gaffe, j'me r√©p√®te pas !

Une base, c'est le nombre de chiffres ou de symboles diff√©rents qu'on peut utiliser pour repr√©senter des nombres. √áa te dit quelque chose le syst√®me d√©cimal, le syst√®me binaire ou le syst√®me hexad√©cimal? C'est √ßa, fr√©rot, c'est des bases. 

1. **Base 10 (syst√®me d√©cimal) :** C'est celle qu'on utilise tous les jours, tu vois? On a dix chiffres, de 0 √† 9. Quand on d√©passe 9, on ajoute 1 √† la colonne de gauche et on repart √† 0. Genre 9 + 1 = 10, t'as capt√©?

2. **Base 2 (syst√®me binaire) :** L√†, on a que deux chiffres, 0 et 1. C'est le langage des ordinateurs, cousin. En binaire, 1 + 1 = 10.

3. **Base 16 (syst√®me hexad√©cimal) :** L√†, c'est un peu plus chaud, on a 16 symboles : de 0 √† 9, et de A √† F pour repr√©senter les nombres de 10 √† 15. En hexa, 9 + 1 = A, et F + 1 = 10.

Donc quand on parle de convertir un nombre d'une base √† une autre, on change juste la fa√ßon de le repr√©senter, mais le nombre reste le m√™me. Genre le nombre 42 en base 10, c'est le m√™me que 101010 en base 2, ou 2A en base 16. C'est clair, fr√©rot ? üî•üëå



```c
void	ft_putnbr_base(int nbr, char *base)
{
	int		base_length;
	int		i;
	char	result[33];

	if (!check_base(base))
		return ;
	base_length = ft_strlen(base);
	i = 0;
	if (nbr < 0)
	{
		ft_putchar('-');
		nbr = -nbr;
	}
	while (nbr)
	{
		result[i++] = base[nbr % base_length];
		nbr /= base_length;
	}
	while (--i >= 0)
		ft_putchar(result[i]);
}
```



1. **`while (nbr)` :** Ce bout de code est une boucle qui continue tant que `nbr` n'est pas √©gal √† 0. En gros, √ßa signifie "tant qu'il reste quelque chose √† convertir dans `nbr`, continue la boucle".

2. **`result[i++] = base[nbr % base_length];` :** Ici, on fait plusieurs choses. D'abord, on calcule `nbr % base_length`, c'est-√†-dire le reste de la division de `nbr` par la longueur de la base. Ce reste, c'est l'indice de notre caract√®re dans la base. Ensuite, on r√©cup√®re ce caract√®re dans la base (`base[nbr % base_length]`) et on l'ajoute √† notre cha√Æne de caract√®res `result` √† l'indice `i`. Et apr√®s tout √ßa, on incr√©mente `i` (c'est ce que fait `i++`).

3. **`nbr /= base_length;` :** L√†, on fait une division enti√®re de `nbr` par la longueur de la base. C'est comme si on "retirait" le dernier chiffre de `nbr`, parce qu'on vient juste de le convertir.

4. **`while (--i >= 0)` :** Cette boucle continue tant que `i` est sup√©rieur ou √©gal √† 0. On d√©cr√©mente `i` √† chaque tour de boucle (c'est ce que fait `--i`), donc on part de la fin de `result` et on remonte jusqu'au d√©but.

5. **`ft_putchar(result[i]);` :** Ici, on affiche le caract√®re √† l'indice `i` dans `result`. Comme on est en train de parcourir `result` √† l'envers (du dernier caract√®re au premier), √ßa nous permet d'afficher notre nombre converti dans le bon sens.



Alors l√† mon pote, faut que tu captes bien la diff√©rence entre `i--` et `--i`. 

Quand tu fais `i--`, c'est ce qu'on appelle un post-d√©cr√©ment: d'abord, tu utilises la valeur de `i` pour ce que tu veux faire, et ensuite seulement tu d√©cr√©mentes `i` de 1. 

Mais quand tu fais `--i`, c'est un pr√©-d√©cr√©ment: avant m√™me de l'utiliser, tu r√©duis `i` de 1, et ensuite tu utilises cette nouvelle valeur de `i` pour ton truc.

Donc dans le bout de code `while (--i >= 0)`, le `--i` fait que tu d√©cr√©mentes `i` AVANT de v√©rifier si `i` est toujours sup√©rieur ou √©gal √† 0.

Pareil pour `i++` et `++i`, sauf que l√† tu ajoutes 1 √† `i` au lieu de le diminuer. 

T'as capt√© le truc, fr√©rot? üòâüëç


La fonction `ft_putnbr_base` prend deux param√®tres : un nombre entier `nbr` et une cha√Æne de caract√®res `base`. Cette fonction a pour but d'afficher `nbr` en utilisant `base` comme syst√®me de num√©ration.

1. **V√©rification de la base :** 

    Tout d'abord, on v√©rifie si la base est valide gr√¢ce √† la fonction `check_base`. Si elle ne l'est pas, la fonction `ft_putnbr_base` s'arr√™te imm√©diatement. Pour √™tre valide, une base ne doit pas √™tre vide, doit avoir une taille sup√©rieure √† 1, ne doit pas contenir deux fois le m√™me caract√®re, et ne doit pas contenir les caract√®res '+' ou '-'.

2. **Initialisation :** 

    Ensuite, on initialise quelques variables. `base_length` contient la longueur de la base, calcul√©e par la fonction `ft_strlen`. On a aussi un tableau `result` qui va contenir le r√©sultat sous forme de cha√Æne de caract√®res, et un indice `i` pour parcourir ce tableau.

3. **Traitement des nombres n√©gatifs :** 

    Si `nbr` est n√©gatif, on commence par afficher un signe '-' puis on transforme `nbr` en positif.

4. **Conversion du nombre :** 

    On va ensuite convertir `nbr` en base `base`. Pour cela, on utilise une boucle while qui continue tant que `nbr` n'est pas nul. √Ä chaque it√©ration, on prend le reste de la division de `nbr` par `base_length`, ce qui donne l'indice du caract√®re dans `base` correspondant √† la derni√®re "chiffre" du nombre en base `base`. On ajoute ce caract√®re √† `result`, puis on divise `nbr` par `base_length`.

5. **Affichage du r√©sultat :** 

    Enfin, une fois que `nbr` est nul, on a obtenu la repr√©sentation de `nbr` en base `base`... mais √† l'envers ! Il faut donc parcourir `result` de la fin au d√©but pour afficher le r√©sultat dans le bon ordre.

Je vais te donner le code en Markdown comme tu l'as demand√©.

```c
void	ft_putnbr_base(int nbr, char *base)
{
	int		base_length;
	int		i;
	char	result[33];

	if (!check_base(base)) // 1. V√©rification de la base
		return ;
	base_length = ft_strlen(base); // 2. Initialisation
	i = 0;
	if (nbr < 0) // 3. Traitement des nombres n√©gatifs
	{
		ft_putchar('-');
		nbr = -nbr;
	}
	while (nbr) // 4. Conversion du nombre
	{
		result[i++] = base[nbr % base_length];
		nbr /= base_length;
	}
	while (--i >= 0) // 5. Affichage du r√©sultat
		ft_putchar(result[i]);
}
```





On va prendre un exemple, disons qu'on veut tester notre fonction avec le nombre 42 et la base 10 (la base de chez nous, quoi). On va aussi tester avec la base 16 (hexad√©cimal) et la base 2 (binaire), histoire de voir un peu comment √ßa se passe. 

C'est parti, accroche-toi √† tes chaussettes, on y va! üëä

```c
int main()
{
	// On va afficher 42 en base 10. R√©sultat attendu : "42"
	ft_putnbr_base(42, "0123456789");
	ft_putchar('\n');
	
	// Maintenant, on va afficher 42 en base 16. R√©sultat attendu : "2A"
	ft_putnbr_base(42, "0123456789ABCDEF");
	ft_putchar('\n');

	// Et pour finir, on affiche 42 en base 2. R√©sultat attendu : "101010"
	ft_putnbr_base(42, "01");
	ft_putchar('\n');

	return (0);
}
```

Et voil√†, c'est tout ce qu'il y a √† savoir sur la fonction `ft_putnbr_base`, mon fr√®re. T'es maintenant un as de la conversion en n'importe quelle base, rien ne peut plus t'arr√™ter. üòéüí™üî•


## Exercice 05 : ft_atoi_base

### Explications

Alors wesh, l√† t'as un truc un peu plus costaud, cousin. On te demande de faire une fonction `ft_atoi_base` qui prend une string et la convertit en nombre entier, sauf que cette fois-ci, t'as aussi une base en entr√©e, pas seulement en base 10. √áa s'passe en plusieurs √©tapes :

1. **V√©rification de la base** : Faut d'abord v√©rifier que la base est valide, c'est-√†-dire qu'elle a au moins deux caract√®res diff√©rents et qu'elle n'a pas de caract√®res en double ou de caract√®res interdits (+, -).

2. **√âlimination des espaces et des signes** : Tu ignores tous les espaces et les signes '+' ou '-' au d√©but de ta cha√Æne comme pour `ft_atoi`, mais tu gardes compte du nombre de '-' pour savoir si ton nombre final doit √™tre positif ou n√©gatif.

3. **Conversion de la cha√Æne en nombre** : L√†, t'as une boucle o√π tu parcours ta cha√Æne et chaque fois que tu trouves un caract√®re qui est dans ta base, tu multiplies le nombre que t'as d√©j√† par la longueur de la base et tu ajoutes la position du caract√®re dans la base.

Allez, on passe au code, fr√©rot ! ‚úåÔ∏èüî•

### Code de la fonction

```c
int	ft_atoi_base(char *str, char *base)
{
	int	i;
	int	sign;
	int	nbr;
	int	base_length;

	if (!is_base_valid(base))
		return (0);
	i = 0;
	sign = 1;
	nbr = 0;
	base_length = ft_strlen(base);
	while (is_whitespace(str[i]))
		i++;
	while (str[i] == '-' || str[i] == '+')
	{
		if (str[i] == '-')
			sign *= -1;
		i++;
	}
	while (is_in_base(str[i], base))
	{
		nbr = nbr * base_length + get_index_in_base(str[i], base);
		i++;
	}
	return (sign * nbr);
}
```

Je vais te d√©tailler cette partie. C'est le c≈ìur du truc, l√† o√π la magie op√®re. üòâ

```c
	while (is_in_base(str[i], base))
	{
		nbr = nbr * base_length + get_index_in_base(str[i], base);
		i++;
	}
```

En fait, cette boucle va parcourir chaque caract√®re de ta string `str` et pour chaque caract√®re, elle va le convertir en un nombre.

Comment ? Elle fait deux choses :

1. **Multiplication du nombre d√©j√† obtenu par la longueur de la base** : C'est comme quand tu passes d'une dizaine √† une centaine en base 10, tu multiplies par 10. L√†, c'est pareil, mais avec la longueur de ta base. Par exemple, si t'es en base 16, tu multiplies par 16.

2. **Ajout de la position du caract√®re dans la base** : Ensuite, tu regardes o√π se trouve ton caract√®re dans ta base. Si ton caract√®re est 'a' et ta base est "0123456789abcdef", alors la position de 'a' est 10. Tu ajoutes cette position √† ton nombre.

Et t'as une fonction `get_index_in_base()` qui fait √ßa, elle te donne la position d'un caract√®re dans ta base.

T'as compris le d√©lire, fr√©rot ? C'est comme si tu d√©codais un message secret, sauf que le message, c'est un nombre et le code secret, c'est ta base. üòéüí™


### Code du main

```c
int main(void)
{
	char *str;
	char *base;

	str = "   ---+--+1234ab567";
	base = "0123456789abcdef";
	printf("%d\n", ft_atoi_base(str, base)); // Doit afficher -19077
	return (0);
}
```

L√†, tu vas avoir un nombre en base 16 (hexad√©cimal) dans ta cha√Æne et tu dois obtenir -19077 en sortie. Tranquille, ou bien, cousin ? üëäüëå
