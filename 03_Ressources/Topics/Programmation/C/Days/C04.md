## Exercice 00 : ft_strlen

Ici, on doit crÃ©er une fonction qui compte le nombre de caractÃ¨res dans une chaÃ®ne de caractÃ¨res, et qui retourne le nombre trouvÃ©. La fonction doit Ãªtre prototypÃ©e comme Ã§a : `int ft_strlen(char *str);`.

Pour faire Ã§a, c'est pas sorcier. On fait une boucle qui parcourt la chaÃ®ne de caractÃ¨res jusqu'Ã  ce qu'elle trouve le caractÃ¨re de fin de chaÃ®ne (qui est '\0' en C). Ã€ chaque fois qu'on passe sur un caractÃ¨re, on incrÃ©mente un compteur. Et c'est ce compteur qu'on retourne Ã  la fin. 

Regarde un peu comment on fait Ã§a :

```c
int ft_strlen(char *str)
{
	int i;

	i = 0;
	while (str[i] != '\0')
	{
		i++;
	}
	return (i);
}
```

Facile, non ? Pour tester cette fonction, on peut l'intÃ©grer dans une fonction main comme Ã§a :

```c
#include <stdio.h>

int main(void)
{
	char str[] = "Salut les potos!";

	printf("La longueur de la chaÃ®ne est : %d\n", ft_strlen(str));
	return (0);
}
```

Quand tu exÃ©cutes ce programme, Ã§a va afficher "La longueur de la chaÃ®ne est : 16", parce que "Salut les potos!" a 16 caractÃ¨res, si on compte les espaces et le point d'exclamation.

Et voilÃ , c'est tout pour le premier exercice du C04. On a crÃ©Ã© une fonction qui compte le nombre de caractÃ¨res dans une chaÃ®ne de caractÃ¨res. C'est une fonction de base en C, mais c'est toujours utile de savoir comment elle fonctionne.


## Exercice 01 : ft_putstr

Pour cet exo, la fonction doit Ãªtre prototypÃ©e comme Ã§a : `void ft_putstr(char *str);`. Et on a le droit d'utiliser la fonction write pour le faire.

En fait, c'est plutÃ´t simple. On va utiliser notre fonction ft_strlen qu'on vient de crÃ©er pour connaÃ®tre la longueur de la chaÃ®ne de caractÃ¨res, et ensuite on utilise write pour l'afficher Ã  l'Ã©cran. Regarde :

```c
#include <unistd.h>

void ft_putstr(char *str)
{
	int len;

	len = ft_strlen(str);
	write(1, str, len);
}
```

Et voilÃ , c'est tout ! Avec cette fonction, tu peux afficher n'importe quelle chaÃ®ne de caractÃ¨res Ã  l'Ã©cran.

Pour tester Ã§a, tu peux utiliser une fonction main comme Ã§a :

```c
int main(void)
{
	char str[] = "Wesh la street !";

	ft_putstr(str);
	return (0);
}
```

Et si tu exÃ©cutes Ã§a, Ã§a va afficher "Wesh la street !" Ã  l'Ã©cran.



## Exercice 02 : ft_putnbr

Ici, on doit Ã©crire une fonction qui va prendre un nombre en paramÃ¨tre et l'afficher Ã  l'Ã©cran. Il faut faire attention, parce qu'il faut pouvoir gÃ©rer tous les nombres possibles d'un int, mÃªme les nÃ©gatifs. Donc on va devoir utiliser une astuce pour gÃ©rer Ã§a.

Voici comment on peut le faire :

```c
#include <unistd.h>

void ft_putchar(char c)
{
	write(1, &c, 1);
}

void ft_putnbr(int nb)
{
	if (nb < 0)
	{
		ft_putchar('-');
		nb = -nb;
	}
	if (nb > 9)
	{
		ft_putnbr(nb / 10);
		ft_putnbr(nb % 10);
	}
	else
		ft_putchar(nb + '0');
}
```

Ici, la fonction ft_putnbr va utiliser une autre fonction, ft_putchar, pour afficher les chiffres un par un. Si le nombre est nÃ©gatif, on met un '-' avant et on change le signe du nombre. Ensuite, on divise le nombre par 10 pour obtenir le chiffre des dizaines, et on utilise le modulo 10 pour obtenir le chiffre des unitÃ©s. On rÃ©pÃ¨te Ã§a tant qu'il reste des chiffres Ã  afficher.

Pour tester Ã§a, tu peux utiliser une fonction main comme Ã§a :

```c
int main(void)
{
	ft_putnbr(42);
	return (0);
}
```

Et si tu exÃ©cutes Ã§a, Ã§a va afficher "42" Ã  l'Ã©cran.

## __   ... petit rappel

L'ASCII, c'est juste une norme qui associe un numÃ©ro Ã  chaque caractÃ¨re qu'on peut taper sur un clavier, chiffres, lettres, symboles, tout Ã§a. Par exemple, le chiffre '0' a le numÃ©ro 48 en ASCII, '1' a le numÃ©ro 49, et ainsi de suite jusqu'Ã  '9' qui a le numÃ©ro 57.

Donc, dans ce code, quand on fait `nb + '0'`, en fait on ajoute le numÃ©ro ASCII de '0' (qui est 48) Ã  notre chiffre. Donc si nb = 0, on a 48 + 0 = 48, donc on affiche '0'. Si nb = 1, on a 48 + 1 = 49, donc on affiche '1', et ainsi de suite.

Pour les nombres Ã  plusieurs chiffres, on utilise une petite astuce avec la division et le modulo. En gros, si on a un nombre comme 123, quand on le divise par 10, on obtient 12 (on ignore le reste). Et si on fait 123 modulo 10, on obtient 3 (le reste de la division par 10). Donc en faisant `ft_putnbr(nb / 10); ft_putnbr(nb % 10);`, on affiche d'abord tous les chiffres sauf le dernier (12), puis on affiche le dernier chiffre (3). Et on fait Ã§a de maniÃ¨re rÃ©cursive, donc pour 12 on va afficher 1 puis 2, et pour 1 on l'affiche directement.

## ___


## Exercice 03 : ft_atoi

LÃ , on doit Ã©crire une fonction qui convertit une chaÃ®ne de caractÃ¨res en un entier. C'est comme la fonction `atoi` dans la bibliothÃ¨que standard C.

Le code pourrait ressembler Ã  quelque chose comme Ã§a :

```c
int	ft_atoi(char *str)
{
	int i;
	int signe;
	int nb;

	i = 0;
	signe = 1;
	nb = 0;
	while (str[i] == ' ' || (str[i] >= 9 && str[i] <= 13))
		i++;
	while (str[i] == '-' || str[i] == '+')
	{
		if (str[i] == '-')
			signe *= -1;
		i++;
	}
	while (str[i] >= '0' && str[i] <= '9')
	{
		nb = nb * 10 + str[i] - '0';
		i++;
	}
	return (signe * nb);
}
```

Bon, on va dÃ©composer ce code :

- Les trois premiÃ¨res boucles while servent Ã  ignorer les espaces et les signes + et - au dÃ©but de la chaÃ®ne. On met Ã  jour le signe en fonction du nombre de signes - qu'on trouve.

- La derniÃ¨re boucle while fait le gros du boulot : elle convertit les chiffres de la chaÃ®ne en nombre. On prend chaque chiffre, on le convertit en nombre en le soustrayant Ã  '0' (comme on a expliquÃ© avant avec l'ASCII), et on l'ajoute Ã  notre nombre total.

Et voilÃ , on a notre fonction `ft_atoi`.

Pour le tester, tu peux utiliser ce petit bout de code :

```c
int main()
{
	char str[] = "   ---+--+1234ab567";
	printf("%d\n", ft_atoi(str));
	return (0);
}
```

Tu devrais voir s'afficher -1234. Si c'est le cas, c'est que ta fonction marche nickel, frÃ©rot ! ğŸ¤˜


## Exercice 04 : ft_putnbr_base

Pour cet exo, tu vas Ã©crire une fonction qui affiche un nombre dans le terminal dans une base donnÃ©e. Tu connais le principe des bases en informatique, pas vrai ? 

Comme d'hab, j'te balance d'abord le code de l'exercice et ensuite on le dÃ©cortique ensemble. Fais gaffe, j'me rÃ©pÃ¨te pas !

Une base, c'est le nombre de chiffres ou de symboles diffÃ©rents qu'on peut utiliser pour reprÃ©senter des nombres. Ã‡a te dit quelque chose le systÃ¨me dÃ©cimal, le systÃ¨me binaire ou le systÃ¨me hexadÃ©cimal? C'est Ã§a, frÃ©rot, c'est des bases. 

1. **Base 10 (systÃ¨me dÃ©cimal) :** C'est celle qu'on utilise tous les jours, tu vois? On a dix chiffres, de 0 Ã  9. Quand on dÃ©passe 9, on ajoute 1 Ã  la colonne de gauche et on repart Ã  0. Genre 9 + 1 = 10, t'as captÃ©?

2. **Base 2 (systÃ¨me binaire) :** LÃ , on a que deux chiffres, 0 et 1. C'est le langage des ordinateurs, cousin. En binaire, 1 + 1 = 10.

3. **Base 16 (systÃ¨me hexadÃ©cimal) :** LÃ , c'est un peu plus chaud, on a 16 symboles : de 0 Ã  9, et de A Ã  F pour reprÃ©senter les nombres de 10 Ã  15. En hexa, 9 + 1 = A, et F + 1 = 10.

Donc quand on parle de convertir un nombre d'une base Ã  une autre, on change juste la faÃ§on de le reprÃ©senter, mais le nombre reste le mÃªme. Genre le nombre 42 en base 10, c'est le mÃªme que 101010 en base 2, ou 2A en base 16. C'est clair, frÃ©rot ? ğŸ”¥ğŸ‘Œ



```c
void	ft_putnbr_base(int nbr, char *base)
{
	int		base_length;
	int		i;
	char	result[33];

	if (!check_base(base))
		return ;
	base_length = ft_strlen(base);
	i = 0;
	if (nbr < 0)
	{
		ft_putchar('-');
		nbr = -nbr;
	}
	while (nbr)
	{
		result[i++] = base[nbr % base_length];
		nbr /= base_length;
	}
	while (--i >= 0)
		ft_putchar(result[i]);
}
```



1. **`while (nbr)` :** Ce bout de code est une boucle qui continue tant que `nbr` n'est pas Ã©gal Ã  0. En gros, Ã§a signifie "tant qu'il reste quelque chose Ã  convertir dans `nbr`, continue la boucle".

2. **`result[i++] = base[nbr % base_length];` :** Ici, on fait plusieurs choses. D'abord, on calcule `nbr % base_length`, c'est-Ã -dire le reste de la division de `nbr` par la longueur de la base. Ce reste, c'est l'indice de notre caractÃ¨re dans la base. Ensuite, on rÃ©cupÃ¨re ce caractÃ¨re dans la base (`base[nbr % base_length]`) et on l'ajoute Ã  notre chaÃ®ne de caractÃ¨res `result` Ã  l'indice `i`. Et aprÃ¨s tout Ã§a, on incrÃ©mente `i` (c'est ce que fait `i++`).

3. **`nbr /= base_length;` :** LÃ , on fait une division entiÃ¨re de `nbr` par la longueur de la base. C'est comme si on "retirait" le dernier chiffre de `nbr`, parce qu'on vient juste de le convertir.

4. **`while (--i >= 0)` :** Cette boucle continue tant que `i` est supÃ©rieur ou Ã©gal Ã  0. On dÃ©crÃ©mente `i` Ã  chaque tour de boucle (c'est ce que fait `--i`), donc on part de la fin de `result` et on remonte jusqu'au dÃ©but.

5. **`ft_putchar(result[i]);` :** Ici, on affiche le caractÃ¨re Ã  l'indice `i` dans `result`. Comme on est en train de parcourir `result` Ã  l'envers (du dernier caractÃ¨re au premier), Ã§a nous permet d'afficher notre nombre converti dans le bon sens.



Alors lÃ  mon pote, faut que tu captes bien la diffÃ©rence entre `i--` et `--i`. 

Quand tu fais `i--`, c'est ce qu'on appelle un post-dÃ©crÃ©ment: d'abord, tu utilises la valeur de `i` pour ce que tu veux faire, et ensuite seulement tu dÃ©crÃ©mentes `i` de 1. 

Mais quand tu fais `--i`, c'est un prÃ©-dÃ©crÃ©ment: avant mÃªme de l'utiliser, tu rÃ©duis `i` de 1, et ensuite tu utilises cette nouvelle valeur de `i` pour ton truc.

Donc dans le bout de code `while (--i >= 0)`, le `--i` fait que tu dÃ©crÃ©mentes `i` AVANT de vÃ©rifier si `i` est toujours supÃ©rieur ou Ã©gal Ã  0.

Pareil pour `i++` et `++i`, sauf que lÃ  tu ajoutes 1 Ã  `i` au lieu de le diminuer. 

T'as captÃ© le truc, frÃ©rot? ğŸ˜‰ğŸ‘


La fonction `ft_putnbr_base` prend deux paramÃ¨tres : un nombre entier `nbr` et une chaÃ®ne de caractÃ¨res `base`. Cette fonction a pour but d'afficher `nbr` en utilisant `base` comme systÃ¨me de numÃ©ration.

1. **VÃ©rification de la base :** 

    Tout d'abord, on vÃ©rifie si la base est valide grÃ¢ce Ã  la fonction `check_base`. Si elle ne l'est pas, la fonction `ft_putnbr_base` s'arrÃªte immÃ©diatement. Pour Ãªtre valide, une base ne doit pas Ãªtre vide, doit avoir une taille supÃ©rieure Ã  1, ne doit pas contenir deux fois le mÃªme caractÃ¨re, et ne doit pas contenir les caractÃ¨res '+' ou '-'.

2. **Initialisation :** 

    Ensuite, on initialise quelques variables. `base_length` contient la longueur de la base, calculÃ©e par la fonction `ft_strlen`. On a aussi un tableau `result` qui va contenir le rÃ©sultat sous forme de chaÃ®ne de caractÃ¨res, et un indice `i` pour parcourir ce tableau.

3. **Traitement des nombres nÃ©gatifs :** 

    Si `nbr` est nÃ©gatif, on commence par afficher un signe '-' puis on transforme `nbr` en positif.

4. **Conversion du nombre :** 

    On va ensuite convertir `nbr` en base `base`. Pour cela, on utilise une boucle while qui continue tant que `nbr` n'est pas nul. Ã€ chaque itÃ©ration, on prend le reste de la division de `nbr` par `base_length`, ce qui donne l'indice du caractÃ¨re dans `base` correspondant Ã  la derniÃ¨re "chiffre" du nombre en base `base`. On ajoute ce caractÃ¨re Ã  `result`, puis on divise `nbr` par `base_length`.

5. **Affichage du rÃ©sultat :** 

    Enfin, une fois que `nbr` est nul, on a obtenu la reprÃ©sentation de `nbr` en base `base`... mais Ã  l'envers ! Il faut donc parcourir `result` de la fin au dÃ©but pour afficher le rÃ©sultat dans le bon ordre.

Je vais te donner le code en Markdown comme tu l'as demandÃ©.

```c
void	ft_putnbr_base(int nbr, char *base)
{
	int		base_length;
	int		i;
	char	result[33];

	if (!check_base(base)) // 1. VÃ©rification de la base
		return ;
	base_length = ft_strlen(base); // 2. Initialisation
	i = 0;
	if (nbr < 0) // 3. Traitement des nombres nÃ©gatifs
	{
		ft_putchar('-');
		nbr = -nbr;
	}
	while (nbr) // 4. Conversion du nombre
	{
		result[i++] = base[nbr % base_length];
		nbr /= base_length;
	}
	while (--i >= 0) // 5. Affichage du rÃ©sultat
		ft_putchar(result[i]);
}
```





On va prendre un exemple, disons qu'on veut tester notre fonction avec le nombre 42 et la base 10 (la base de chez nous, quoi). On va aussi tester avec la base 16 (hexadÃ©cimal) et la base 2 (binaire), histoire de voir un peu comment Ã§a se passe. 

C'est parti, accroche-toi Ã  tes chaussettes, on y va! ğŸ‘Š

```c
int main()
{
	// On va afficher 42 en base 10. RÃ©sultat attendu : "42"
	ft_putnbr_base(42, "0123456789");
	ft_putchar('\n');
	
	// Maintenant, on va afficher 42 en base 16. RÃ©sultat attendu : "2A"
	ft_putnbr_base(42, "0123456789ABCDEF");
	ft_putchar('\n');

	// Et pour finir, on affiche 42 en base 2. RÃ©sultat attendu : "101010"
	ft_putnbr_base(42, "01");
	ft_putchar('\n');

	return (0);
}
```

Et voilÃ , c'est tout ce qu'il y a Ã  savoir sur la fonction `ft_putnbr_base`, mon frÃ¨re. T'es maintenant un as de la conversion en n'importe quelle base, rien ne peut plus t'arrÃªter. ğŸ˜ğŸ’ªğŸ”¥


## Exercice 05 : ft_atoi_base

### Explications

Alors wesh, lÃ  t'as un truc un peu plus costaud, cousin. On te demande de faire une fonction `ft_atoi_base` qui prend une string et la convertit en nombre entier, sauf que cette fois-ci, t'as aussi une base en entrÃ©e, pas seulement en base 10. Ã‡a s'passe en plusieurs Ã©tapes :

1. **VÃ©rification de la base** : Faut d'abord vÃ©rifier que la base est valide, c'est-Ã -dire qu'elle a au moins deux caractÃ¨res diffÃ©rents et qu'elle n'a pas de caractÃ¨res en double ou de caractÃ¨res interdits (+, -).

2. **Ã‰limination des espaces et des signes** : Tu ignores tous les espaces et les signes '+' ou '-' au dÃ©but de ta chaÃ®ne comme pour `ft_atoi`, mais tu gardes compte du nombre de '-' pour savoir si ton nombre final doit Ãªtre positif ou nÃ©gatif.

3. **Conversion de la chaÃ®ne en nombre** : LÃ , t'as une boucle oÃ¹ tu parcours ta chaÃ®ne et chaque fois que tu trouves un caractÃ¨re qui est dans ta base, tu multiplies le nombre que t'as dÃ©jÃ  par la longueur de la base et tu ajoutes la position du caractÃ¨re dans la base.

Allez, on passe au code, frÃ©rot ! âœŒï¸ğŸ”¥

### Code de la fonction

```c
int	ft_atoi_base(char *str, char *base)
{
	int	i;
	int	sign;
	int	nbr;
	int	base_length;

	if (!is_base_valid(base))
		return (0);
	i = 0;
	sign = 1;
	nbr = 0;
	base_length = ft_strlen(base);
	while (is_whitespace(str[i]))
		i++;
	while (str[i] == '-' || str[i] == '+')
	{
		if (str[i] == '-')
			sign *= -1;
		i++;
	}
	while (is_in_base(str[i], base))
	{
		nbr = nbr * base_length + get_index_in_base(str[i], base);
		i++;
	}
	return (sign * nbr);
}
```

Je vais te dÃ©tailler cette partie. C'est le cÅ“ur du truc, lÃ  oÃ¹ la magie opÃ¨re. ğŸ˜‰

```c
	while (is_in_base(str[i], base))
	{
		nbr = nbr * base_length + get_index_in_base(str[i], base);
		i++;
	}
```

En fait, cette boucle va parcourir chaque caractÃ¨re de ta string `str` et pour chaque caractÃ¨re, elle va le convertir en un nombre.

Comment ? Elle fait deux choses :

1. **Multiplication du nombre dÃ©jÃ  obtenu par la longueur de la base** : C'est comme quand tu passes d'une dizaine Ã  une centaine en base 10, tu multiplies par 10. LÃ , c'est pareil, mais avec la longueur de ta base. Par exemple, si t'es en base 16, tu multiplies par 16.

2. **Ajout de la position du caractÃ¨re dans la base** : Ensuite, tu regardes oÃ¹ se trouve ton caractÃ¨re dans ta base. Si ton caractÃ¨re est 'a' et ta base est "0123456789abcdef", alors la position de 'a' est 10. Tu ajoutes cette position Ã  ton nombre.

Et t'as une fonction `get_index_in_base()` qui fait Ã§a, elle te donne la position d'un caractÃ¨re dans ta base.

T'as compris le dÃ©lire, frÃ©rot ? C'est comme si tu dÃ©codais un message secret, sauf que le message, c'est un nombre et le code secret, c'est ta base. ğŸ˜ğŸ’ª


### Code du main

```c
int main(void)
{
	char *str;
	char *base;

	str = "   ---+--+1234ab567";
	base = "0123456789abcdef";
	printf("%d\n", ft_atoi_base(str, base)); // Doit afficher -19077
	return (0);
}
```

LÃ , tu vas avoir un nombre en base 16 (hexadÃ©cimal) dans ta chaÃ®ne et tu dois obtenir -19077 en sortie. Tranquille, ou bien, cousin ? ğŸ‘ŠğŸ‘Œ
