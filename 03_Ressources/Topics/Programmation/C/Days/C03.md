## Exercice 00 : ft_strcmp

Yo, fr√©rot, on d√©bute le C03 avec l'exercice 00 qui nous demande de reproduire la fonction [[strcmp]]. Cette fonction, elle compare deux cha√Ænes de caract√®res et nous dit si elles sont identiques ou pas. 

Le code de la fonction ft_strcmp, c'est √ßa :

```c
int	ft_strcmp(char *s1, char *s2)
{
	int i;

	i = 0;
	while (s1[i] && s2[i] && s1[i] == s2[i])
		i++;
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
}
```

Elle parcourt les deux cha√Ænes en m√™me temps et d√®s qu'elle trouve un caract√®re qui diff√®re, elle retourne la diff√©rence entre les deux. Si les deux cha√Ænes sont identiques, elle retourne 0. 

Maintenant, pour tester √ßa, tu peux ajouter un main comme √ßa :

```c
int main(void)
{
	char s1[] = "abc";
	char s2[] = "abd";
	char s3[] = "abc";
	
	printf("%d\n", ft_strcmp(s1, s2)); // √ßa affiche -1
	printf("%d\n", ft_strcmp(s1, s3)); // √ßa affiche 0
	return (0);
}
```

Ici, tu vois que "abc" et "abd" sont pas identiques, donc √ßa affiche -1. Par contre, "abc" et "abc" sont les m√™mes, donc √ßa affiche 0. 

Allez, c'est parti pour le prochain exercice, cousin! üí™üî•


## Exercice 01 : ft_strncmp

Allez, on continue la vibe, cousin! L√† on est sur l'exercice 01 qui nous demande de reproduire la fonction [[strncmp]]. C'est un peu comme [[strcmp]], sauf qu'on compare que les 'n' premiers caract√®res des deux cha√Ænes. 

Voil√† √† quoi ressemble la fonction ft_strncmp :

```c
int	ft_strncmp(char *s1, char *s2, unsigned int n)
{
	unsigned int i;

	i = 0;
	while (i < n && s1[i] && s2[i] && s1[i] == s2[i])
		i++;
	if (i == n)
		return (0);
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
}
```

Pour tester cette fonction, tu peux utiliser ce main :

```c
int main(void)
{
	char s1[] = "abcde";
	char s2[] = "abfde";
	char s3[] = "abcde";
	
	printf("%d\n", ft_strncmp(s1, s2, 3)); // √ßa affiche 0
	printf("%d\n", ft_strncmp(s1, s2, 4)); // √ßa affiche -1
	printf("%d\n", ft_strncmp(s1, s3, 5)); // √ßa affiche 0
	return (0);
}
```

Ici, tu remarques que les 3 premiers caract√®res de "abcde" et "abfde" sont identiques, donc √ßa affiche 0. Par contre, si on compare les 4 premiers, y'a une diff√©rence donc √ßa affiche -1. Et bien s√ªr, "abcde" et "abcde" sont identiques donc √ßa affiche 0.

On avance bien, fr√©rot! Allez, on se bouge pour le prochain exercice! üí™üöÄ


## Exercice 02 : ft_strcat

Reproduire la fonction [[strcat]]
Allez, on l√¢che rien! L√† on va s'occuper de la fonction ft_strcat. C'est une fonction qui va coller une cha√Æne de caract√®res √† la suite d'une autre. 

Jette un ≈ìil √† ce code:

```c
char	*ft_strcat(char *dest, char *src)
{
	int i;
	int j;

	i = 0;
	while (dest[i])
		i++;
	j = 0;
	while (src[j])
	{
		dest[i] = src[j];
		i++;
		j++;
	}
	dest[i] = '\0';
	return (dest);
}
```

Et pour le tester, tu peux utiliser ce main :

```c
int main(void)
{
	char dest[50] = "Salut, ";
	char src[] = "√ßa va?";

	printf("%s\n", ft_strcat(dest, src)); // √ßa affiche "Salut, √ßa va?"
	return (0);
}
```

Ici, on a "Salut, " et "√ßa va?" et la fonction ft_strcat va les coller ensemble pour obtenir "Salut, √ßa va?". Simple comme bonjour, hein? üòé

Allez, on continue l'aventure!

## Exercice 03 : ft_strncat

Reproduire la fonction [[strncat]] ...

Wesh, mon gars, on continue avec le m√™me genre de bail. Mais cette fois-ci, on a une petite variante : on ajoute seulement un certain nombre de caract√®res de la cha√Æne source √† la cha√Æne de destination. Pas toute la cha√Æne, juste un certain nombre de caract√®res. Voici comment tu peux faire √ßa :

```c
char	*ft_strncat(char *dest, char *src, unsigned int nb)
{
	unsigned int	i;
	unsigned int	j;

	i = 0;
	while (dest[i])
		i++;
	j = 0;
	while (src[j] && j < nb)
	{
		dest[i] = src[j];
		i++;
		j++;
	}
	dest[i] = '\0';
	return (dest);
}
```

Ce code est presque le m√™me que le pr√©c√©dent, fr√©rot. La seule diff√©rence, c'est la condition dans la deuxi√®me boucle `while (src[j] && j < nb)`. On s'arr√™te maintenant non seulement quand on atteint la fin de `src`, mais aussi quand on a copi√© `nb` caract√®res. 

Pour le tester, c'est pareil que le dernier. Voici comment tu peux le faire :

```c
int main(void)
{
	char dest[50] = "Salut, ";
	char src[] = "√ßa va bien?";

	printf("%s\n", ft_strncat(dest, src, 5)); // √ßa affiche "Salut, √ßa va"
	return (0);
}
```

Ici, on copie seulement les 5 premiers caract√®res de "√ßa va bien?" √† la fin de "Salut, ". Donc on obtient "Salut, √ßa va". C'est pas plus dur que √ßa, cousin! üòé

Allez, on passe √† la suite!


## Exercice 04 : ft_strstr


Allez, fr√©rot, on attaque l'exercice 04 maintenant. Cette fois, il faut reproduire le fonctionnement de la fonction [[strstr]]. Cette fonction cherche une sous-cha√Æne (la cha√Æne `to_find`) dans une autre cha√Æne (`str`). Si elle la trouve, elle retourne un pointeur sur le d√©but de cette sous-cha√Æne dans `str`. Sinon, elle retourne NULL. Regarde comment tu peux coder √ßa :

```c
char	*ft_strstr(char *str, char *to_find)
{
	int i;
	int j;

	i = 0;
	if (!*to_find)
		return (str);
	while (str[i])
	{
		j = 0;
		while (str[i + j] == to_find[j])
		{
			if (!to_find[j + 1])
				return (str + i);
			j++;
		}
		i++;
	}
	return (0);
}
```

Ici, on parcourt `str` avec `i` et `to_find` avec `j`. Quand on trouve un caract√®re dans `str` qui est le m√™me que le premier caract√®re de `to_find`, on compare les caract√®res suivants. Si tous les caract√®res correspondent, on a trouv√© la sous-cha√Æne et on retourne un pointeur sur le d√©but de cette sous-cha√Æne dans `str`. Si on n'a pas trouv√© la sous-cha√Æne apr√®s avoir parcouru toute la cha√Æne `str`, on retourne NULL.

Pour tester cette fonction, tu peux faire un truc comme √ßa :

```c
int main(void)
{
	char str[] = "Je suis un grand fan de rap fran√ßais.";

	printf("%s\n", ft_strstr(str, "rap")); // √ßa affiche "rap fran√ßais."
	return (0);
}
```

Dans cet exemple, "rap" est une sous-cha√Æne de `str`. Donc `ft_strstr` retourne un pointeur sur le d√©but de "rap" dans `str`, et `printf` affiche la cha√Æne √† partir de ce point, c'est-√†-dire "rap fran√ßais.".

Allez, on continue, poto ! üöÄ


## Exercice 05 : ft_strlcat

Bon, cousin, on attaque l'exercice 05 maintenant. L√†, il faut reproduire le fonctionnement de la fonction [[strlcat]]. Cette fonction concat√®ne deux cha√Ænes, mais pas n'importe comment. Elle prend en compte la taille du tampon de destination. Si le tampon de destination est trop petit, elle s'arr√™te avant d'√©craser la m√©moire qui suit. Voil√† comment tu peux coder √ßa :

```c
unsigned int	ft_strlcat(char *dest, char *src, unsigned int size)
{
	unsigned int i;
	unsigned int j;

	i = 0;
	while (dest[i] && i < size)
		i++;
	j = 0;
	while (src[j] && (i + j + 1) < size)
	{
		dest[i + j] = src[j];
		j++;
	}
	if (i != size)
		dest[i + j] = '\0';
	return (i + ft_strlen(src));
}
```

Dans ce code, on commence par trouver la fin de la cha√Æne `dest` avec `i`. Ensuite, on ajoute les caract√®res de `src` √† la fin de `dest` jusqu'√† ce qu'on atteigne la taille `size` ou la fin de `src`. Enfin, on ajoute un caract√®re nul √† la fin de `dest` pour terminer la cha√Æne, √† moins qu'on ait atteint la taille `size` sans trouver la fin de `dest`.

Pour tester cette fonction, tu peux faire un truc comme √ßa :

```c
int main(void)
{
	char dest[30] = "Je suis un";
	char src[] = " grand fan de rap fran√ßais.";

	printf("%u\n", ft_strlcat(dest, src, sizeof(dest)));
	printf("%s\n", dest);
	return (0);
}
```

Dans cet exemple, `ft_strlcat` ajoute `src` √† la fin de `dest` et affiche la longueur de la cha√Æne r√©sultante. Puis `printf` affiche la cha√Æne r√©sultante.


Alors, pour ce main :

```C
int main(void)
{
	char dest[30] = "Je suis un";
	char src[] = " grand fan de rap fran√ßais.";

	printf("%u\n", ft_strlcat(dest, src, sizeof(dest)));
	printf("%s\n", dest);
	return (0);
}
```

La taille de `dest` est 30, et la longueur actuelle de la chaine `dest` est 10 ("Je suis un" a 10 caract√®res). Donc il reste 20 emplacements libres dans `dest` (on compte le '\0' √† la fin). 

La fonction `ft_strlcat` va essayer de copier `src` dans `dest`, mais elle ne peut copier que jusqu'√† `sizeof(dest) - strlen(dest) - 1` caract√®res (pour laisser la place au '\0' √† la fin).

Donc elle va copier 19 caract√®res de `src` vers `dest` (parce que 30 - 10 - 1 = 19), et `dest` deviendra "Je suis un grand fan de rap fr".

Et puis la fonction `ft_strlcat` renvoie la taille initiale de `dest` (qui est 10) plus la taille de `src` (qui est 26), donc √ßa fait 36.

Donc si tu fais :

```C
printf("%u\n", ft_strlcat(dest, src, sizeof(dest)));
printf("%s\n", dest);
```

L'output √ßa va √™tre :

```C
36
Je suis un grand fan de rap fr
```

T'as vu, c'est un peu tordu comme truc. üòÖ J'esp√®re que c'est plus clair maintenant! üôè

