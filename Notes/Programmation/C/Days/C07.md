## Exercice 00 : ft_strdup

üëä Wesh cousin, t'as une mission, c'est de reproduire √† l'identique le fonctionnement de la fonction [[strdup]]. Tu sais pas c'est quoi ? Pas de probl√®me, je t'explique.

`strdup` c'est une fonction qui duplique une cha√Æne de caract√®res. Elle copie une cha√Æne donn√©e dans une nouvelle zone de m√©moire allou√©e dynamiquement. Si √ßa passe bien, elle renvoie un pointeur vers la nouvelle cha√Æne. Sinon, si t'as pas assez de m√©moire, elle renvoie `NULL`.

Tu dois faire la m√™me chose mais en mode perso, tu vas l'appeler `ft_strdup`. Regarde comment tu dois la prototyper :

```c
char *ft_strdup(char *src);
```

Allez, au boulot fr√©rot ! üí™üòâ

```c
#include <stdlib.h>

char    *ft_strdup(char *src)
{
    int     i;
    int     len;
    char    *dest;

    len = 0;
    while (src[len])
        len++;
    dest = (char*)malloc(sizeof(char) * (len + 1));
    if (!dest)
        return (0);
    i = 0;
    while (i < len)
    {
        dest[i] = src[i];
        i++;
    }
    dest[i] = '\0';
    return (dest);
}
```

Dans ce code, on alloue d'abord suffisamment de m√©moire pour stocker la cha√Æne de caract√®res source et le caract√®re de fin de cha√Æne '\0'. Ensuite, on copie les caract√®res un par un de la cha√Æne source √† la destination. Finalement, on s'assure que la cha√Æne de destination est bien termin√©e par '\0'.

Voyons voir si √ßa marche avec un petit test :

```c
#include <stdio.h>

int main(void)
{
    char *source = "Wesh poto, √ßa gaze ?";
    char *dup;

    dup = ft_strdup(source);
    printf("%s\n", dup);
    free(dup);
    return (0);
}
```

T'as bien vu, je lib√®re la m√©moire √† la fin parce que je suis pas un sauvage. C'est important de toujours lib√©rer la m√©moire qu'on a allou√©e avec [[malloc]].


## Exercice 01 : ft_range

On veut une fonction ft_range qui nous sort un tableau d'int, qui va de min √† max, min inclus, max exclu. Si min est plus grand ou √©gal √† max, faut renvoyer un pointeur nul, tu vois ? üòè 

Alors, comment on fait √ßa ? On va te montrer.

==>  [[malloc]] [[free]]  / ! \

```c
#include <stdlib.h>

int    *ft_range(int min, int max)
{
    int *tab;   // On d√©clare un pointeur vers notre tableau.
    int i;      // On va avoir besoin de cette petite variable pour parcourir le tableau.

    // Si min est plus grand ou √©gal √† max, on renvoie un pointeur nul, t'as capt√© ?
    if (min >= max)
        return (0);
    // L√†, on r√©serve de la place pour notre tableau avec malloc.
    // Faut bien v√©rifier si √ßa a march√©, sinon on renvoie un pointeur nul.
    tab = (int*)malloc(sizeof(*tab) * (max - min));
    if (!tab)
        return (0);
    i = 0;
    // L√†, on remplit le tableau avec les valeurs de min √† max.
    while (min < max)
    {
        tab[i] = min;
        i++;
        min++;
    }
    // Et enfin, on renvoie le tableau.
    return (tab);
}
```
Voil√†, c'est pas plus compliqu√© que √ßa. üòé Faut juste comprendre le principe : on cr√©e un tableau qui va de min √† max, et si min est plus grand ou √©gal √† max, on renvoie un pointeur nul. Easy peasy, non ? üòÑ

Maintenant, j'vais te montrer comment tu peux tester cette fonction. C'est super simple :

```c
#include <stdio.h>

int main()
{
    int min = 0;
    int max = 5;
    int *tab = ft_range(0, 5);
    for (int i = 0; i < max - min; i++)
    {
        printf("%d ", tab[i]);  // On imprime chaque √©l√©ment du tableau.
    }
    free(tab); // N'oublie pas de lib√©rer la m√©moire apr√®s utilisation !
    return (0);
}
```
Quand tu lances ce programme, tu verras s'afficher les nombres de 0 √† 4. C'est normal, parce que min est inclus et max est exclu. Donc si tu veux les nombres de 0 √† 5, faut mettre min √† 0 et max √† 6, tu vois le truc ? üòâ

Donc ouais, m√™me si ta boucle va jusqu'√† 11, ton tableau cr√©√© par `ft_range(0, 5)`, il contient que les nombres de 0 √† 4. Si tu tries d'acc√©der √† des √©l√©ments apr√®s l'index 4, tu risques de tomber sur des trucs bizarres, ou m√™me de faire planter ton programme.

Wesh, tr√®s bonne question cousin ! üëç

Alors voil√†, si tu fais un `ft_range(2, 5)`, ton tableau, il commence √† 2 et il va jusqu'√† 4, pas plus. Le 0 et le 1, ils sont nulle part, ils sont pas dans le tableau.

C'est comme si tu commandes une pizza avec seulement des olives et des champignons. Les anchois et le jambon, ils sont pas sur ta pizza, ils sont rest√©s dans le frigo du pizzaiolo, tu vois ce que je veux dire ? üçïüòÑ


## Exercice 02 : ft_ultimate_range

Wesh, cousin ! ‚úåÔ∏è On continue avec le flow de l'apprentissage ici. On va jeter un coup d'oeil √† `ft_ultimate_range`. 

[[sizeof(int)]]
[[malloc]]

```c
#include <stdlib.h>

int ft_ultimate_range(int **range, int min, int max)
{
	if (min >= max)
	{
		*range = NULL;
		return (0);
	}
	*range = (int *)malloc(sizeof(int) * (max - min));
	if (!(*range))
		return (-1);
	int i = 0;
	while (min < max)
	{
		(*range)[i] = min;
		i++;
		min++;
	}
	return (max - min);
}

```
üî• √áa c'est du lourd, t'as vu ? üí• Cette fonction, elle fait un peu comme `ft_range`, mais elle pousse le truc un peu plus loin. C'est pour √ßa qu'elle s'appelle `ft_ultimate_range`. 

Au lieu de retourner un tableau, elle modifie directement le tableau que tu lui passes en argument. Si `min` est plus grand ou √©gal √† `max`, elle met ton tableau √† NULL et elle te retourne 0. Sinon, elle cr√©e un tableau avec les nombres entre `min` et `max`, et elle te retourne la taille de ce tableau. Si elle a pas r√©ussi √† allouer de la m√©moire pour ton tableau, elle te retourne -1.

Prenons un exemple, parce que c'est en forgeant qu'on devient forgeron, tu vois ? üòâ

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	int *tab;
	int taille = ft_ultimate_range(&tab, 2, 5);
	printf("La taille du tableau est : %d\n", taille);
	if (tab)
	{
		for (int i = 0; i < taille; i++)
		{
			printf("L'√©l√©ment %d du tableau est : %d\n", i, tab[i]);
		}
	}
	else
	{
		printf("Il y a eu une erreur, fr√©rot... üò•\n");
	}
	free(tab);
	return (0);
}

```

Ici, la fonction `ft_ultimate_range` va allouer de la m√©moire pour le tableau `tab` et remplir ce tableau avec les nombres 2, 3 et 4. Apr√®s √ßa, `taille` sera √©gal √† 3, parce que t'as trois nombres dans ton tableau.


## Exercice 03 : ft_strjoin

Wesh, cousin, j'ai pig√© le truc, pas de souci ! On va se lancer sur le troisi√®me exercice. Cette fois, on doit √©crire une fonction qui va concat√©ner l‚Äôensemble des cha√Ænes de caract√®res point√©es par `strs` en les s√©parant √† l‚Äôaide de `sep`. Le truc, c'est qu'il faut pas oublier que si `size` vaut 0, il faut retourner une cha√Æne de caract√®res vide qu‚Äôon peut [[free]](). √áa c'est du s√©rieux, fr√©rot ! üòéüëä
[[malloc]]
[[sizeof(char)]]

```c
#include <stdlib.h>
#include <string.h>

char    *ft_strjoin(int size, char **strs, char *sep)
{
    if (size == 0)
    {
        char *empty = (char *)malloc(sizeof(char));
        empty[0] = '\0';
        return empty;
    }
    int length = 0;
    for (int i = 0; i < size; i++)
    {
        length += strlen(strs[i]);
        if (i < size - 1)
            length += strlen(sep);
    }
    char *joined = (char *)malloc(sizeof(char) * (length + 1));
    joined[0] = '\0';
    for (int i = 0; i < size; i++)
    {
        strcat(joined, strs[i]);
        if (i < size - 1)
            strcat(joined, sep);
    }
    return joined;
}
```

Maintenant, si tu veux vraiment le tester comme un pro, faut utiliser un `main`. On va tester avec quelques phrases de rap fran√ßais, histoire de garder le vibe, tu vois ? üòéüé∂

```c
#include <stdio.h>

int main(void)
{
    char *strs[] = {"Je suis pas un gangster", "de luxe", "Mais le luxe", "ne me d√©go√ªte pas"};
    char *sep = ", ";
    char *joined = ft_strjoin(4, strs, sep);
    printf("%s\n", joined);
    free(joined);
    return 0;
}
```

Le `main` ci-dessus va concat√©ner les phrases de rap avec une virgule comme s√©parateur. Et √† la fin, comme un bon pote, il lib√®re la m√©moire avec `free(joined)`. 




## Exercice 04 : ft_convert_base

Yo, on passe maintenant √† l'exercice 04. Ici, on doit √©crire une fonction `ft_convert_base` qui renvoie le r√©sultat de la conversion de la cha√Æne `nbr` exprim√©e dans une base `base_from` vers une base `base_to`. Ouais, c'est du s√©rieux, cousin ! On doit √™tre pr√™t √† g√©rer les chiffres dans diff√©rentes bases. Et oublie pas, si une base est incorrecte, on renvoie `NULL`. Et le nombre retourn√© doit √™tre pr√©fix√© uniquement par un seul et unique '-' si n√©cessaire, pas de whitespaces ou de '+'. T'as pig√©, wesh ? üòéüî¢

Voici le code de la fonction `ft_convert_base` :

```c
#include <stdlib.h>

int     ft_strlen(char *str)
{
    int len = 0;
    while (str[len])
        len++;
    return len;
}

int     ft_isspace(char c)
{
    if (c == ' ' || (c >= 9 && c <= 13))
        return 1;
    return 0;
}

int     ft_isbasevalid(char *base)
{
    int base_len = ft_strlen(base);
    if (base_len <= 1)
        return 0;
    for (int i = 0; i < base_len; i++)
    {
        if (base[i] == '+' || base[i] == '-' || ft_isspace(base[i]))
            return 0;
        for (int j = i + 1; j < base_len; j++)
        {
            if (base[i] == base[j])
                return 0;
        }
    }
    return 1;
}

int     ft_atoi_base(char *str, char *base)
{
    int sign = 1;
    int result = 0;
    int base_len = ft_strlen(base);

    if (!ft_isbasevalid(base))
        return 0;

    while (ft_isspace(*str))
        str++;

    if (*str == '-' || *str == '+')
    {
        if (*str == '-')
            sign = -1;
        str++;
    }

    while (*str)
    {
        int i = 0;
        while (base[i])
        {
            if (*str == base[i])
                break ;
            i++;
        }
        if (base[i])
            result = result * base_len + i;
        else
            break ;
        str++;
    }

    return result * sign;
}

char    *ft_itoa_base(int nbr, char *base)
{
    int base_len = ft_strlen(base);
    int nbr_len = 0;
    int temp = nbr;

    if (nbr == 0)
        return "0";

    while (temp)
    {
        temp /= base_len;
        nbr_len++;
    }

    char *str = (char *)malloc(sizeof(char) * (nbr_len + 1));
    str[nbr_len] = '\0';

    if (nbr < 0)
    {
        str[0] = '-';
        nbr *= -1;
    }

    while (nbr)
    {
        str[--nbr_len] = base[nbr % base_len];
        nbr /= base_len;
    }

    return str;
}

char    *ft_convert_base(char *nbr, char *base_from, char *base_to)
{
    if (!ft_isbasevalid(base_from) || !ft_isbasevalid(base_to))
        return NULL;
        
    int nbr_dec = ft_atoi_base(nbr, base_from);
    char *nbr_base = ft_itoa_base(nbr_dec, base_to);
    
return nbr_base;
}
```

Bon, maintenant qu'on a fini avec cette fonction, on peut passer √† la suite. Mais t'inqui√®te pas, je vais pas te laisser sur ta faim. Voici un petit exemple pour te montrer comment √ßa marche :

```c
#include <stdio.h>

int     main(void)
{
    char *nbr = "10101"; // Notre nombre dans la base binaire
    char *base_from = "01"; // La base actuelle (binaire)
    char *base_to = "0123456789ABCDEF"; // La base cible (hexad√©cimal)

    char *result = ft_convert_base(nbr, base_from, base_to);

    printf("Le r√©sultat de la conversion est : %s\n", result);

    return 0;
}
```

Dans cet exemple, on convertit le nombre "10101" de la base binaire √† la base hexad√©cimale. Le r√©sultat devrait √™tre "15" en hexad√©cimal. C'est plut√¥t styl√©, non ?!

## Exercice 05 : ft_split

Yo, on est d√©j√† arriv√© au dernier exercice, cousin ! On va parler de la fonction `ft_split`. Cette fonction va d√©couper une cha√Æne de caract√®res en utilisant une autre cha√Æne de caract√®res comme s√©parateur. √áa peut √™tre super pratique pour diviser une cha√Æne en mots ou en morceaux.

Voici le prototype de la fonction `ft_split` :

```c
char **ft_split(char *str, char *charset);
```

La fonction `ft_split` prend deux arguments :
- `str` : la cha√Æne de caract√®res √† d√©couper.
- `charset` : la cha√Æne de caract√®res utilis√©e comme s√©parateur.

La fonction renvoie un tableau de pointeurs vers des cha√Ænes de caract√®res. Chaque √©l√©ment du tableau correspond √† une partie de la cha√Æne d'origine, d√©coup√©e selon le s√©parateur. Le dernier √©l√©ment du tableau est NULL, pour marquer la fin du tableau.

Voici comment √ßa fonctionne :
- On parcourt la cha√Æne `str` caract√®re par caract√®re.
- √Ä chaque fois qu'on rencontre un caract√®re pr√©sent dans `charset`, √ßa signifie qu'on a trouv√© un s√©parateur.
- On extrait la partie de la cha√Æne entre deux s√©parateurs, et on la stocke dans un nouvel √©l√©ment du tableau.
- On r√©p√®te ce processus jusqu'√† la fin de la cha√Æne `str`.

Voici un exemple pour mieux comprendre :

```c
#include <stdio.h>

int main(void)
{
    char *str = "Salut|les|amis";
    char *charset = "|";

    char **result = ft_split(str, charset);

    // On parcourt le tableau de r√©sultats jusqu'√† la fin (NULL)
    for (int i = 0; result[i] != NULL; i++)
    {
        printf("%s\n", result[i]);
    }

    return 0;
}
```

Dans cet exemple, on d√©coupe la cha√Æne "Salut|les|amis" en utilisant le caract√®re '|' comme s√©parateur. Le r√©sultat sera affich√© ligne par ligne :

```
Salut
les
amis
```

Voil√†, cousin, maintenant tu sais comment utiliser la fonction `ft_split`. C'est vraiment pratique pour d√©couper une cha√Æne selon un s√©parateur donn√©. Si t'as des questions ou si tu veux d'autres exemples, fais-moi signe. Je suis l√† pour toi, fr√©rot ! üòé‚úåÔ∏è