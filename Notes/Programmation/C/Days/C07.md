## Exercice 00 : ft_strdup

👊 Wesh cousin, t'as une mission, c'est de reproduire à l'identique le fonctionnement de la fonction [[strdup]]. Tu sais pas c'est quoi ? Pas de problème, je t'explique.

`strdup` c'est une fonction qui duplique une chaîne de caractères. Elle copie une chaîne donnée dans une nouvelle zone de mémoire allouée dynamiquement. Si ça passe bien, elle renvoie un pointeur vers la nouvelle chaîne. Sinon, si t'as pas assez de mémoire, elle renvoie `NULL`.

Tu dois faire la même chose mais en mode perso, tu vas l'appeler `ft_strdup`. Regarde comment tu dois la prototyper :

```c
char *ft_strdup(char *src);
```

Allez, au boulot frérot ! 💪😉

```c
#include <stdlib.h>

char    *ft_strdup(char *src)
{
    int     i;
    int     len;
    char    *dest;

    len = 0;
    while (src[len])
        len++;
    dest = (char*)malloc(sizeof(char) * (len + 1));
    if (!dest)
        return (0);
    i = 0;
    while (i < len)
    {
        dest[i] = src[i];
        i++;
    }
    dest[i] = '\0';
    return (dest);
}
```

Dans ce code, on alloue d'abord suffisamment de mémoire pour stocker la chaîne de caractères source et le caractère de fin de chaîne '\0'. Ensuite, on copie les caractères un par un de la chaîne source à la destination. Finalement, on s'assure que la chaîne de destination est bien terminée par '\0'.

Voyons voir si ça marche avec un petit test :

```c
#include <stdio.h>

int main(void)
{
    char *source = "Wesh poto, ça gaze ?";
    char *dup;

    dup = ft_strdup(source);
    printf("%s\n", dup);
    free(dup);
    return (0);
}
```

T'as bien vu, je libère la mémoire à la fin parce que je suis pas un sauvage. C'est important de toujours libérer la mémoire qu'on a allouée avec [[malloc]].


## Exercice 01 : ft_range

On veut une fonction ft_range qui nous sort un tableau d'int, qui va de min à max, min inclus, max exclu. Si min est plus grand ou égal à max, faut renvoyer un pointeur nul, tu vois ? 😏 

Alors, comment on fait ça ? On va te montrer.

==>  [[malloc]] [[free]]  / ! \

```c
#include <stdlib.h>

int    *ft_range(int min, int max)
{
    int *tab;   // On déclare un pointeur vers notre tableau.
    int i;      // On va avoir besoin de cette petite variable pour parcourir le tableau.

    // Si min est plus grand ou égal à max, on renvoie un pointeur nul, t'as capté ?
    if (min >= max)
        return (0);
    // Là, on réserve de la place pour notre tableau avec malloc.
    // Faut bien vérifier si ça a marché, sinon on renvoie un pointeur nul.
    tab = (int*)malloc(sizeof(*tab) * (max - min));
    if (!tab)
        return (0);
    i = 0;
    // Là, on remplit le tableau avec les valeurs de min à max.
    while (min < max)
    {
        tab[i] = min;
        i++;
        min++;
    }
    // Et enfin, on renvoie le tableau.
    return (tab);
}
```
Voilà, c'est pas plus compliqué que ça. 😎 Faut juste comprendre le principe : on crée un tableau qui va de min à max, et si min est plus grand ou égal à max, on renvoie un pointeur nul. Easy peasy, non ? 😄

Maintenant, j'vais te montrer comment tu peux tester cette fonction. C'est super simple :

```c
#include <stdio.h>

int main()
{
    int min = 0;
    int max = 5;
    int *tab = ft_range(0, 5);
    for (int i = 0; i < max - min; i++)
    {
        printf("%d ", tab[i]);  // On imprime chaque élément du tableau.
    }
    free(tab); // N'oublie pas de libérer la mémoire après utilisation !
    return (0);
}
```
Quand tu lances ce programme, tu verras s'afficher les nombres de 0 à 4. C'est normal, parce que min est inclus et max est exclu. Donc si tu veux les nombres de 0 à 5, faut mettre min à 0 et max à 6, tu vois le truc ? 😉

Donc ouais, même si ta boucle va jusqu'à 11, ton tableau créé par `ft_range(0, 5)`, il contient que les nombres de 0 à 4. Si tu tries d'accéder à des éléments après l'index 4, tu risques de tomber sur des trucs bizarres, ou même de faire planter ton programme.

Wesh, très bonne question cousin ! 👍

Alors voilà, si tu fais un `ft_range(2, 5)`, ton tableau, il commence à 2 et il va jusqu'à 4, pas plus. Le 0 et le 1, ils sont nulle part, ils sont pas dans le tableau.

C'est comme si tu commandes une pizza avec seulement des olives et des champignons. Les anchois et le jambon, ils sont pas sur ta pizza, ils sont restés dans le frigo du pizzaiolo, tu vois ce que je veux dire ? 🍕😄


## Exercice 02 : ft_ultimate_range

Wesh, cousin ! ✌️ On continue avec le flow de l'apprentissage ici. On va jeter un coup d'oeil à `ft_ultimate_range`. 

[[sizeof(int)]]
[[malloc]]

```c
#include <stdlib.h>

int ft_ultimate_range(int **range, int min, int max)
{
	if (min >= max)
	{
		*range = NULL;
		return (0);
	}
	*range = (int *)malloc(sizeof(int) * (max - min));
	if (!(*range))
		return (-1);
	int i = 0;
	while (min < max)
	{
		(*range)[i] = min;
		i++;
		min++;
	}
	return (max - min);
}

```
🔥 Ça c'est du lourd, t'as vu ? 💥 Cette fonction, elle fait un peu comme `ft_range`, mais elle pousse le truc un peu plus loin. C'est pour ça qu'elle s'appelle `ft_ultimate_range`. 

Au lieu de retourner un tableau, elle modifie directement le tableau que tu lui passes en argument. Si `min` est plus grand ou égal à `max`, elle met ton tableau à NULL et elle te retourne 0. Sinon, elle crée un tableau avec les nombres entre `min` et `max`, et elle te retourne la taille de ce tableau. Si elle a pas réussi à allouer de la mémoire pour ton tableau, elle te retourne -1.

Prenons un exemple, parce que c'est en forgeant qu'on devient forgeron, tu vois ? 😉

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	int *tab;
	int taille = ft_ultimate_range(&tab, 2, 5);
	printf("La taille du tableau est : %d\n", taille);
	if (tab)
	{
		for (int i = 0; i < taille; i++)
		{
			printf("L'élément %d du tableau est : %d\n", i, tab[i]);
		}
	}
	else
	{
		printf("Il y a eu une erreur, frérot... 😥\n");
	}
	free(tab);
	return (0);
}

```

Ici, la fonction `ft_ultimate_range` va allouer de la mémoire pour le tableau `tab` et remplir ce tableau avec les nombres 2, 3 et 4. Après ça, `taille` sera égal à 3, parce que t'as trois nombres dans ton tableau.


## Exercice 03 : ft_strjoin

Wesh, cousin, j'ai pigé le truc, pas de souci ! On va se lancer sur le troisième exercice. Cette fois, on doit écrire une fonction qui va concaténer l’ensemble des chaînes de caractères pointées par `strs` en les séparant à l’aide de `sep`. Le truc, c'est qu'il faut pas oublier que si `size` vaut 0, il faut retourner une chaîne de caractères vide qu’on peut [[free]](). Ça c'est du sérieux, frérot ! 😎👊
[[malloc]]
[[sizeof(char)]]

```c
#include <stdlib.h>
#include <string.h>

char    *ft_strjoin(int size, char **strs, char *sep)
{
    if (size == 0)
    {
        char *empty = (char *)malloc(sizeof(char));
        empty[0] = '\0';
        return empty;
    }
    int length = 0;
    for (int i = 0; i < size; i++)
    {
        length += strlen(strs[i]);
        if (i < size - 1)
            length += strlen(sep);
    }
    char *joined = (char *)malloc(sizeof(char) * (length + 1));
    joined[0] = '\0';
    for (int i = 0; i < size; i++)
    {
        strcat(joined, strs[i]);
        if (i < size - 1)
            strcat(joined, sep);
    }
    return joined;
}
```

Maintenant, si tu veux vraiment le tester comme un pro, faut utiliser un `main`. On va tester avec quelques phrases de rap français, histoire de garder le vibe, tu vois ? 😎🎶

```c
#include <stdio.h>

int main(void)
{
    char *strs[] = {"Je suis pas un gangster", "de luxe", "Mais le luxe", "ne me dégoûte pas"};
    char *sep = ", ";
    char *joined = ft_strjoin(4, strs, sep);
    printf("%s\n", joined);
    free(joined);
    return 0;
}
```

Le `main` ci-dessus va concaténer les phrases de rap avec une virgule comme séparateur. Et à la fin, comme un bon pote, il libère la mémoire avec `free(joined)`. 




## Exercice 04 : ft_convert_base

Yo, on passe maintenant à l'exercice 04. Ici, on doit écrire une fonction `ft_convert_base` qui renvoie le résultat de la conversion de la chaîne `nbr` exprimée dans une base `base_from` vers une base `base_to`. Ouais, c'est du sérieux, cousin ! On doit être prêt à gérer les chiffres dans différentes bases. Et oublie pas, si une base est incorrecte, on renvoie `NULL`. Et le nombre retourné doit être préfixé uniquement par un seul et unique '-' si nécessaire, pas de whitespaces ou de '+'. T'as pigé, wesh ? 😎🔢

Voici le code de la fonction `ft_convert_base` :

```c
#include <stdlib.h>

int     ft_strlen(char *str)
{
    int len = 0;
    while (str[len])
        len++;
    return len;
}

int     ft_isspace(char c)
{
    if (c == ' ' || (c >= 9 && c <= 13))
        return 1;
    return 0;
}

int     ft_isbasevalid(char *base)
{
    int base_len = ft_strlen(base);
    if (base_len <= 1)
        return 0;
    for (int i = 0; i < base_len; i++)
    {
        if (base[i] == '+' || base[i] == '-' || ft_isspace(base[i]))
            return 0;
        for (int j = i + 1; j < base_len; j++)
        {
            if (base[i] == base[j])
                return 0;
        }
    }
    return 1;
}

int     ft_atoi_base(char *str, char *base)
{
    int sign = 1;
    int result = 0;
    int base_len = ft_strlen(base);

    if (!ft_isbasevalid(base))
        return 0;

    while (ft_isspace(*str))
        str++;

    if (*str == '-' || *str == '+')
    {
        if (*str == '-')
            sign = -1;
        str++;
    }

    while (*str)
    {
        int i = 0;
        while (base[i])
        {
            if (*str == base[i])
                break ;
            i++;
        }
        if (base[i])
            result = result * base_len + i;
        else
            break ;
        str++;
    }

    return result * sign;
}

char    *ft_itoa_base(int nbr, char *base)
{
    int base_len = ft_strlen(base);
    int nbr_len = 0;
    int temp = nbr;

    if (nbr == 0)
        return "0";

    while (temp)
    {
        temp /= base_len;
        nbr_len++;
    }

    char *str = (char *)malloc(sizeof(char) * (nbr_len + 1));
    str[nbr_len] = '\0';

    if (nbr < 0)
    {
        str[0] = '-';
        nbr *= -1;
    }

    while (nbr)
    {
        str[--nbr_len] = base[nbr % base_len];
        nbr /= base_len;
    }

    return str;
}

char    *ft_convert_base(char *nbr, char *base_from, char *base_to)
{
    if (!ft_isbasevalid(base_from) || !ft_isbasevalid(base_to))
        return NULL;
        
    int nbr_dec = ft_atoi_base(nbr, base_from);
    char *nbr_base = ft_itoa_base(nbr_dec, base_to);
    
return nbr_base;
}
```

Bon, maintenant qu'on a fini avec cette fonction, on peut passer à la suite. Mais t'inquiète pas, je vais pas te laisser sur ta faim. Voici un petit exemple pour te montrer comment ça marche :

```c
#include <stdio.h>

int     main(void)
{
    char *nbr = "10101"; // Notre nombre dans la base binaire
    char *base_from = "01"; // La base actuelle (binaire)
    char *base_to = "0123456789ABCDEF"; // La base cible (hexadécimal)

    char *result = ft_convert_base(nbr, base_from, base_to);

    printf("Le résultat de la conversion est : %s\n", result);

    return 0;
}
```

Dans cet exemple, on convertit le nombre "10101" de la base binaire à la base hexadécimale. Le résultat devrait être "15" en hexadécimal. C'est plutôt stylé, non ?!

## Exercice 05 : ft_split

Yo, on est déjà arrivé au dernier exercice, cousin ! On va parler de la fonction `ft_split`. Cette fonction va découper une chaîne de caractères en utilisant une autre chaîne de caractères comme séparateur. Ça peut être super pratique pour diviser une chaîne en mots ou en morceaux.

Voici le prototype de la fonction `ft_split` :

```c
char **ft_split(char *str, char *charset);
```

La fonction `ft_split` prend deux arguments :
- `str` : la chaîne de caractères à découper.
- `charset` : la chaîne de caractères utilisée comme séparateur.

La fonction renvoie un tableau de pointeurs vers des chaînes de caractères. Chaque élément du tableau correspond à une partie de la chaîne d'origine, découpée selon le séparateur. Le dernier élément du tableau est NULL, pour marquer la fin du tableau.

Voici comment ça fonctionne :
- On parcourt la chaîne `str` caractère par caractère.
- À chaque fois qu'on rencontre un caractère présent dans `charset`, ça signifie qu'on a trouvé un séparateur.
- On extrait la partie de la chaîne entre deux séparateurs, et on la stocke dans un nouvel élément du tableau.
- On répète ce processus jusqu'à la fin de la chaîne `str`.

Voici un exemple pour mieux comprendre :

```c
#include <stdio.h>

int main(void)
{
    char *str = "Salut|les|amis";
    char *charset = "|";

    char **result = ft_split(str, charset);

    // On parcourt le tableau de résultats jusqu'à la fin (NULL)
    for (int i = 0; result[i] != NULL; i++)
    {
        printf("%s\n", result[i]);
    }

    return 0;
}
```

Dans cet exemple, on découpe la chaîne "Salut|les|amis" en utilisant le caractère '|' comme séparateur. Le résultat sera affiché ligne par ligne :

```
Salut
les
amis
```

Voilà, cousin, maintenant tu sais comment utiliser la fonction `ft_split`. C'est vraiment pratique pour découper une chaîne selon un séparateur donné. Si t'as des questions ou si tu veux d'autres exemples, fais-moi signe. Je suis là pour toi, frérot ! 😎✌️