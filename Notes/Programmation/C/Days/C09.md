
## Exercice 00 : libft

Dans cet exercice, vous √™tes cens√© cr√©er une biblioth√®que libft.a qui contient un ensemble de fonctions, √† savoir `ft_putchar`, `ft_swap`, `ft_putstr`, `ft_strlen` et `ft_strcmp`.

**√âtape 1 : √âcrire les fichiers sources**

Voici les codes pour chaque fichier .c. Tous ces fichiers doivent √™tre cr√©√©s dans le dossier `srcs`.

* `ft_putchar.c`:

```c
#include <unistd.h>

void ft_putchar(char c)
{
    write(1, &c, 1);
}
```

* `ft_swap.c`:

```c
void ft_swap(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}
```

* `ft_putstr.c`:

```c
void ft_putstr(char *str)
{
    while(*str)
    {
        ft_putchar(*str);
        str++;
    }
}
```

* `ft_strlen.c`:

```c
int ft_strlen(char *str)
{
    int length = 0;
    while(*str)
    {
        length++;
        str++;
    }
    return length;
}
```

* `ft_strcmp.c`:

```c
int ft_strcmp(char *s1, char *s2)
{
    while(*s1 && (*s1 == *s2))
    {
        s1++;
        s2++;
    }
    return *(unsigned char*)s1 - *(unsigned char*)s2;
}
```

**√âtape 2 : √âcrire le fichier header**

Le fichier `ft.h` doit √™tre cr√©√© dans le dossier `includes`. Il d√©clare toutes les fonctions pour que d'autres fichiers puissent les utiliser.

```c
#ifndef FT_H
#define FT_H

void ft_putchar(char c);
void ft_swap(int *a, int *b);
void ft_putstr(char *str);
int  ft_strlen(char *str);
int  ft_strcmp(char *s1, char *s2);

#endif
```

**√âtape 3 : √âcrire le script libft_creator.sh**

Ce script shell compile tous les fichiers .c et cr√©e la biblioth√®que libft.a. 

```shell
#!/bin/sh
gcc -c -Wall -Wextra -Werror ./srcs/ft_putchar.c ./srcs/ft_swap.c ./srcs/ft_putstr.c ./srcs/ft_strlen.c ./srcs/ft_strcmp.c
ar rc libft.a ft_putchar.o ft_swap.o ft_putstr.o ft_strlen.o ft_strcmp.o
ranlib libft.a
rm *.o
```

Ce script comprend plusieurs commandes :

- `gcc -c -Wall -Wextra -Werror`: compile les fichiers sources en fichiers objet.
- `ar rc libft.a`: cr√©e la biblioth√®que √† partir des fichiers objet.
- `ranlib libft.a`: indexe la biblioth√®que.
- `rm *.o`: supprime les fichiers objet apr√®s avoir cr√©√© la biblioth√®que.

Vous pouvez ex√©cuter le script avec la commande suivante:

```shell
sh libft_creator.sh
```

En suivant ces instructions, vous aurez cr√©√© une biblioth√®que qui contient les fonctions demand√©es par l'exercice 00.


## Exercice 01 : Makefile

L√†, il te faut cr√©er un Makefile qui va compiler une librairie `libft.a`. C'est quoi un Makefile ? C'est un fichier qui permet de g√©rer la compilation de ton code plus facilement, sans te prendre la t√™te. 

Pour √ßa, faut que tu respectes quelques r√®gles dans ton Makefile.

**√âtape 1 : Cr√©ation du Makefile**

Dans ton dossier `ex01/`, faut que tu cr√©es un fichier appel√© `Makefile`. Attention aux majuscules, fr√©rot.

Voil√† ce que tu devrais mettre dedans :

```makefile
NAME = libft.a
SRC = srcs/ft_putchar.c srcs/ft_swap.c srcs/ft_putstr.c srcs/ft_strlen.c srcs/ft_strcmp.c
OBJ = $(SRC:.c=.o)
INCLUDES = includes
CC = gcc
CFLAGS = -Wall -Wextra -Werror

all: $(NAME)

$(NAME): $(OBJ)
	ar rc $(NAME) $(OBJ)
	ranlib $(NAME)

%.o: %.c
	$(CC) -I $(INCLUDES) -o $@ -c $< $(CFLAGS)

clean:
	rm -f $(OBJ)

fclean: clean
	rm -f $(NAME)

re: fclean all
```

Pour comprendre ce qui se passe ici, voil√† la signification des diff√©rents √©l√©ments du Makefile :

- `NAME`: c'est le nom de ta biblioth√®que.
- `SRC`: c'est la liste de tes fichiers sources.
- `OBJ`: c'est la liste de tes fichiers objets. Ils seront cr√©√©s √† partir des fichiers sources.
- `INCLUDES`: c'est le dossier o√π se trouvent tes fichiers header.
- `CC`: c'est le compilateur que tu utilises, ici c'est gcc.
- `CFLAGS`: ce sont les options de compilation.

Les r√®gles `all`, `clean`, `fclean` et `re` font diff√©rentes choses :

- `all`: c'est la r√®gle par d√©faut. Elle cr√©e ta biblioth√®que.
- `clean`: elle supprime les fichiers objets.
- `fclean`: elle supprime les fichiers objets ET la biblioth√®que.
- `re`: elle fait `fclean` puis `all`.

Maintenant que t'as ton Makefile, tu peux compiler ta biblioth√®que avec la commande `make`. Et si tu veux nettoyer tout √ßa, tu fais `make fclean`.



## Exercice 02 : ft_split

C'est quoi le d√©lire ici ? On veut une fonction qui d√©coupe une cha√Æne de caract√®res en fonction d'une autre cha√Æne de caract√®res. Chaque caract√®re de la chaine `charset` est un s√©parateur.

Voil√† le prototype de la fonction :

```c
char **ft_split(char *str, char *charset);
```

T'as pig√© ? Bon, j'explique quand m√™me. `str` c'est ta chaine de caract√®res √† d√©couper et `charset` c'est la chaine qui va servir de s√©parateur. 

On renvoie un tableau de chaines de caract√®res (un tableau de pointeurs sur char). Chaque case du tableau contient une partie de la chaine originale qui √©tait entre deux s√©parateurs.

Fais gaffe √† deux trucs : 

1. Ta chaine de caract√®res d'origine `str` ne doit pas √™tre modifi√©e.
2. Le dernier √©l√©ment du tableau doit √™tre √† 0 pour indiquer la fin du tableau.

Comme d'hab, tu peux utiliser `malloc` pour allouer de la m√©moire. 

Bon, c'est pas √©vident ce truc. Le plus simple, c'est d'y aller √©tape par √©tape. 

**√âtape 1 : Compter le nombre de mots**

Avant de d√©couper quoi que ce soit, il faut savoir combien de mots tu vas avoir dans ton tableau. Un mot, c'est quoi ? C'est une partie de la chaine qui est entre deux s√©parateurs.

Tu peux √©crire une fonction `count_words` qui fait √ßa. Elle parcourt la chaine et √† chaque fois qu'elle tombe sur un s√©parateur, elle incr√©mente un compteur. 

**√âtape 2 : Allouer de la m√©moire pour le tableau**

Maintenant que tu sais combien de mots tu as, tu peux allouer de la m√©moire pour ton tableau avec `malloc`. Fais gaffe √† bien allouer une case de plus pour le 0 final.

**√âtape 3 : D√©couper la chaine**

Maintenant, le morceau de bravoure. Il faut d√©couper la chaine. Pour chaque mot, tu vas allouer de la m√©moire, puis copier le mot dedans, puis ajouter ce mot √† ton tableau.

C'est pas simple, √ßa demande un peu de gymnastique mentale. Mais si tu te concentres et que tu fais √ßa √©tape par √©tape, √ßa devrait le faire.

Voil√† un exemple de ce que pourrait donner ta fonction :

```c
char    **ft_split(char *str, char *charset)
{
    char    **tab;
    int     i;
    int     j;
    int     k;

    if (!(tab = malloc(sizeof(char*) * (count_words(str, charset) + 1))))
        return (NULL);
    i = 0;
    k = 0;
    while (str[i])
    {
        while (str[i] && is_separator(str[i], charset))
            i++;
        j = 0;
        while (str[i + j] && !is_separator(str[i + j], charset))
            j++;
        if (j > 0)
        {
            tab[k] = ft_strndup(&str[i], j);
            k++;
        }
        i += j;
    }
    tab[k] = 0;
    return (tab);
}
```

On met 0 dans la derni√®re case du tableau, et on renvoie le tableau. Simple, cousin.

Mais t'as d√ª remarquer qu'il y a des fonctions qu'on a pas encore d√©finies : `count_words`, `is_separator` et `ft_strndup`. On va s'en occuper maintenant.

`count_words` compte le nombre de mots dans la chaine `str`, un mot √©tant d√©fini comme une suite de caract√®res qui sont pas dans `charset`. Tu la d√©finis comme √ßa :

```c
int     count_words(char *str, char *charset)
{
    int i;
    int count;

    i = 0;
    count = 0;
    while (str[i])
    {
        while (str[i] && is_separator(str[i], charset))
            i++;
        if (str[i] && !is_separator(str[i], charset))
        {
            count++;
            while (str[i] && !is_separator(str[i], charset))
                i++;
        }
    }
    return (count);
}
```

`is_separator` v√©rifie si un caract√®re fait partie des s√©parateurs. 

```c
int     is_separator(char c, char *charset)
{
    while (*charset)
        if (c == *charset++)
            return (1);
    return (0);
}
```

Et `ft_strndup` copie une partie de la chaine `str`. Elle prend en argument le point de d√©part et le nombre de caract√®res √† copier.

```c
char    *ft_strndup(char *str, int n)
{
    char    *copy;
    int     i;

    if (!(copy = malloc(sizeof(char) * (n + 1))))
        return (NULL);
    i = 0;
    while (i < n)
    {
        copy[i] = str[i];
        i++;
    }
    copy[i] = '\0';
    return (copy);
}
```

Et voil√†, tu as ta fonction `ft_split`. J'esp√®re que c'est pas trop dur √† suivre, mais en gros, on d√©coupe la chaine en morceaux et on met chaque morceau dans un tableau. Un peu comme si tu prenais une baguette et que tu la coupais en tranches pour faire des tartines, tu vois le d√©lire ? üòéü•ñ


