## Exercice 00 : ft.h

Wesh mon pote, on va commencer doux avec un fichier de dÃ©claration de fonctions. ğŸ¤™

```c
#ifndef FT_H
#define FT_H

// Toutes ces fonctions, faut dÃ©clarer ici, mon frÃ¨re
void ft_putchar(char c);
void ft_swap(int *a, int *b);
void ft_putstr(char *str);
int  ft_strlen(char *str);
int  ft_strcmp(char *s1, char *s2);

#endif
```
Ce code, c'est juste un fichier de dÃ©claration, cousin. Pas besoin de le tester. C'est pas un code Ã  compiler et exÃ©cuter, mais t'inquiÃ¨te, je te montrerai comment le faire dans les prochains exercices.


Dans la programmation en C, les fichiers .h sont appelÃ©s "fichiers d'en-tÃªte". Ils sont gÃ©nÃ©ralement utilisÃ©s pour dÃ©finir des dÃ©clarations de fonctions, des macros et des dÃ©finitions de types qui seront utilisÃ©s dans plusieurs fichiers sources .c.

Passons maintenant Ã  ton code, frÃ©rot.

```c
#ifndef FT_H
#define FT_H
```

Ces deux lignes forment ce qu'on appelle une "garde d'inclusion". 
Cette structure empÃªche le contenu du fichier d'Ãªtre inclus plusieurs fois lors de la compilation. Si FT_H n'est pas dÃ©fini, alors il le dÃ©finit et continue Ã  compiler le reste du fichier. 
Si FT_H est dÃ©jÃ  dÃ©fini (ce qui signifierait que le fichier a dÃ©jÃ  Ã©tÃ© inclus), 
il ignore le reste du fichier.

- `#ifndef FT_H`Â est une directive conditionnelle qui vÃ©rifie siÂ `FT_H`Â n'a pas dÃ©jÃ  Ã©tÃ© dÃ©fini. SiÂ `FT_H`Â n'est pas dÃ©fini, alors le code qui suit (jusqu'Ã Â `#endif`) est inclus dans le programme.
    
- `#define FT_H`Â dÃ©finitÂ `FT_H`. Donc, la prochaine fois que le prÃ©processeur rencontreÂ `#ifndef FT_H`, il verra queÂ `FT_H`Â est dÃ©jÃ  dÃ©fini et n'inclura pas le code une deuxiÃ¨me fois.

```c
// Toutes ces fonctions, faut dÃ©clarer ici, mon frÃ¨re
void ft_putchar(char c);
void ft_swap(int *a, int *b);
void ft_putstr(char *str);
int  ft_strlen(char *str);
int  ft_strcmp(char *s1, char *s2);
```

Ces lignes dÃ©clarent cinq fonctions. Les dÃ©clarations de fonction ne contiennent pas de code de fonction, elles indiquent seulement le type de valeur que la fonction renvoie et les types de ses paramÃ¨tres. Les dÃ©clarations permettent au compilateur de vÃ©rifier que les fonctions sont appelÃ©es correctement dans les fichiers .c qui incluent le fichier .h.

```c
#endif
```

Cette ligne marque la fin de la garde d'inclusion. 
Tout ce qui se trouve entre `#ifndef FT_H` et `#endif` est inclus une fois et une seule lors de la compilation.

La directiveÂ `#endif`Â en C est utilisÃ©e pour marquer la fin d'un bloc conditionnel commencÃ© parÂ `#if`,Â `#ifdef`Â ouÂ `#ifndef`.

Dans votre code,Â `#ifndef FT_H`Â ouvre un bloc conditionnel qui inclut tout le code jusqu'Ã Â `#endif`. SiÂ `FT_H`Â n'a pas Ã©tÃ© dÃ©fini, alors tout le code entreÂ `#ifndef FT_H`Â etÂ `#endif`Â est pris en compte par le compilateur.

`#endif`Â est donc utilisÃ© pour indiquer la fin du bloc conditionnel. SansÂ `#endif`, le prÃ©processeur C ne saurait pas oÃ¹ se termine le bloc conditionnel et cela entraÃ®nerait une erreur de compilation.

En somme, le code entreÂ `#ifndef FT_H`Â etÂ `#endif`Â ne sera inclus dans votre programme que siÂ `FT_H`Â n'a pas encore Ã©tÃ© dÃ©fini. C'est une pratique courante pour Ã©viter les problÃ¨mes d'inclusion multiple lorsqu'un fichier d'en-tÃªte est inclus plusieurs fois.


Donc, en gros, ce fichier .h dÃ©clare des fonctions qui peuvent Ãªtre utilisÃ©es dans plusieurs fichiers .c. Pour les utiliser, il suffit d'inclure le fichier .h en haut de chaque fichier .c qui utilise ces fonctions, comme Ã§a :

```c
#include "ft.h"
```

Et voilÃ , frÃ©rot. C'est le fonctionnement de base des fichiers .h en C. Tu peux maintenant utiliser ces fonctions dÃ©clarÃ©es dans n'importe quel fichier .c en incluant simplement ft.h. 


## Exercice 01 : ft_boolean.h

Pour ce bazar, faut faire un fichier header qui dÃ©finit les types de boolÃ©ens et quelques constantes. C'est parti, mon khey.

```c
#ifndef FT_BOOLEAN_H
#define FT_BOOLEAN_H

#include <unistd.h>

#define TRUE 1
#define FALSE 0
#define EVEN(nbr) (nbr % 2 == 0)
#define SUCCESS 0

#define EVEN_MSG "I have an even number of arguments.\n"
#define ODD_MSG "I have an odd number of arguments.\n"

typedef int t_bool;

#endif
```

Ce code est Ã©galement une bibliothÃ¨que d'en-tÃªte C, plus spÃ©cifiquement appelÃ©eÂ `FT_BOOLEAN_H`. Tout comme dans l'exemple prÃ©cÃ©dent, les directivesÂ `#ifndef`,Â `#define`Â etÂ `#endif`Â sont utilisÃ©es pour Ã©viter les inclusions multiples.

Dans ce code, plusieurs macros et un nouveau type sont dÃ©finis :

1. `#include <unistd.h>`Â : C'est une inclusion de bibliothÃ¨que standard Unix qui fournit des macros, des types et des fonctions pour les opÃ©rations d'E/S.
    
2. `#define TRUE 1`Â : C'est une macro qui dÃ©finitÂ `TRUE`Â commeÂ `1`.
    
3. `#define FALSE 0`Â : C'est une macro qui dÃ©finitÂ `FALSE`Â commeÂ `0`.
    
4. `#define EVEN(nbr) (nbr % 2 == 0)`Â : C'est une macro qui prend un argumentÂ `nbr`Â et renvoieÂ `TRUE`Â (ouÂ `1`) siÂ `nbr`Â est pair, etÂ `FALSE`Â (ouÂ `0`) sinon.
    
5. `#define SUCCESS 0`Â : C'est une macro qui dÃ©finitÂ `SUCCESS`Â commeÂ `0`. Dans la plupart des langages de programmation,Â `0`Â est gÃ©nÃ©ralement utilisÃ© pour indiquer qu'une opÃ©ration s'est terminÃ©e avec succÃ¨s.
    
6. `#define EVEN_MSG "I have an even number of arguments.\n"`Â : C'est une macro qui dÃ©finitÂ `EVEN_MSG`Â comme la chaÃ®ne de caractÃ¨resÂ `"I have an even number of arguments.\n"`.
    
7. `#define ODD_MSG "I have an odd number of arguments.\n"`Â : C'est une macro qui dÃ©finitÂ `ODD_MSG`Â comme la chaÃ®ne de caractÃ¨resÂ `"I have an odd number of arguments.\n"`.
    
8. `typedef int t_bool`Â : C'est une dÃ©claration de type qui dÃ©finitÂ `t_bool`Â comme un alias pourÂ `int`. Vous pouvez utiliserÂ `t_bool`Â comme un type de donnÃ©es dans votre code, et il sera traitÃ© comme unÂ `int`Â par le compilateur.
    

Ainsi, ce fichier d'en-tÃªte fournit un ensemble de macros et de dÃ©finitions de types qui peuvent Ãªtre utiles pour manipuler des boolÃ©ens, vÃ©rifier si un nombre est pair, et renvoyer des messages spÃ©cifiques pour les nombres pairs et impairs.



Et lÃ  encore, c'est un fichier de dÃ©claration, pas besoin de le tester directement. Mais si tu veux Ãªtre sÃ»r que Ã§a marche, tu peux utiliser ce fichier dans un code C, comme celui qui est donnÃ© dans l'exercice, pour voir si Ã§a compile. Allez, on passe Ã  l'Ã©tape suivante, cousin.


Pour cet exercice, tu dois crÃ©er un autre fichier d'en-tÃªte, appelÃ© `ft_boolean.h`. Ce fichier d'en-tÃªte contiendra la dÃ©claration d'une fonction `ft_is_even`, ainsi que plusieurs macros et un nouveau type, `t_bool`.

Dans le monde du C, on n'a pas de type `boolean` intÃ©grÃ© comme dans d'autres langages. Alors, pour reprÃ©senter les valeurs boolÃ©ennes `true` et `false`, on utilise gÃ©nÃ©ralement des macros avec les valeurs 1 et 0, respectivement. Dans cet exercice, ces macros sont `TRUE` et `FALSE`.

La dÃ©claration de la fonction `ft_is_even` est aussi nÃ©cessaire dans ce fichier d'en-tÃªte. Cette fonction prend un entier en entrÃ©e et renvoie `TRUE` si l'entier est pair, sinon elle renvoie `FALSE`.

Un autre macro `EVEN` est dÃ©fini pour vÃ©rifier si un nombre est pair.

Enfin, il y a une macro pour chaque message qui sera affichÃ© selon que le nombre d'arguments est pair ou impair (`EVEN_MSG` et `ODD_MSG`), et une macro pour la valeur de succÃ¨s (`SUCCESS`).

Tout cela forme le fichier `ft_boolean.h`. Pour l'utiliser, tu dois l'inclure dans le fichier .c qui utilise les macros et les fonctions dÃ©finies dans `ft_boolean.h`, exactement comme tu l'as fait avec `ft.h`.

Supposons que nous voulions vÃ©rifier si le nombre d'arguments passÃ©s au programme est pair ou impair.

```c
#include "ft_boolean.h"

void ft_putstr(char *str)
{
    while (*str)
        write(1, str++, 1);
}

int main(int argc, char **argv)
{
    (void)argv;
    if (EVEN(argc - 1))
        ft_putstr(EVEN_MSG);
    else
        ft_putstr(ODD_MSG);
    return (SUCCESS);
}

```

Dans ce programme, nous dÃ©finissons d'abord la fonctionÂ `ft_putstr`Â qui Ã©crit une chaÃ®ne de caractÃ¨res sur la sortie standard. Nous utilisons ensuite la macroÂ `EVEN`Â pour vÃ©rifier si le nombre d'arguments est pair. Si c'est le cas, nous affichonsÂ `EVEN_MSG`Â ; sinon, nous affichonsÂ `ODD_MSG`.

La raison pour laquelle nous faisonsÂ `argc - 1`Â lors de la vÃ©rification avecÂ `EVEN`Â est queÂ `argc`Â compte aussi le nom du programme comme argument, donc pour obtenir le nombre d'arguments rÃ©ellement passÃ©s au programme, nous devons soustraire 1.

Notez Ã©galement l'utilisation deÂ `(void)argv;`Â - ceci est utilisÃ© pour Ã©viter un avertissement du compilateur concernant une variable non utilisÃ©e, car nous n'utilisons pasÂ `argv`Â dans ce programme.


Vous pouvez l'exÃ©cuter avec diffÃ©rents nombres d'arguments pour tester :

`./monprogramme arg1 arg2 ./monprogramme arg1 arg2 arg3`

Et ainsi de suite.



## Exercice 02 : ft_abs.h

Pour cet exercice, tu dois crÃ©er un autre fichier d'en-tÃªte, `ft_abs.h`, qui contiendra une macro `ABS`. Cette macro est destinÃ©e Ã  remplacer une valeur donnÃ©e par sa valeur absolue. 

En langage C, une valeur absolue d'un nombre est sa valeur sans tenir compte de son signe. Si le nombre est nÃ©gatif, sa valeur absolue est le nombre positif correspondant. Si le nombre est dÃ©jÃ  positif, sa valeur absolue est le mÃªme nombre. 

Pour rÃ©aliser cela avec une macro en C, on utilise l'opÃ©rateur conditionnel (aussi appelÃ© l'opÃ©rateur ternaire) qui prend trois opÃ©randes: une condition, une valeur si la condition est vraie, et une valeur si la condition est fausse. 

Voici comment cela pourrait ressembler:

```c
#define ABS(Value) ((Value < 0) ? -Value : Value)
```

C'est simple, n'est-ce pas ? Une fois que tu as crÃ©Ã© le fichier `ft_abs.h` avec cette macro, tu peux l'inclure dans n'importe quel fichier .c qui nÃ©cessite d'utiliser la valeur absolue d'un nombre. 



## Exercice 03 : ft_point.h

Pour cet exercice, tu dois crÃ©er un autre fichier d'en-tÃªte, `ft_point.h`. Dans ce fichier, tu dois dÃ©finir une structure `t_point` qui reprÃ©sente un point dans un espace Ã  deux dimensions, avec des coordonnÃ©es `x` et `y`.

Voici un exemple de comment tu pourrais dÃ©finir cette structure :

```c
typedef struct  s_point
{
    int x;
    int y;
}               t_point;
```

Une fois que tu as dÃ©fini cette structure, tu peux l'utiliser pour dÃ©clarer des variables de type `t_point` et accÃ©der Ã  leurs champs `x` et `y`. Par exemple, dans le main qui t'est donnÃ©, tu as une variable `point` de type `t_point` Ã  laquelle tu attribues des valeurs en utilisant la fonction `set_point`.



## Exercice 04 : ft_strs_to_tab

Dans ce programme, nous allons crÃ©er une structure qui stocke les informations sur une chaÃ®ne de caractÃ¨res. Ensuite, nous allons Ã©crire quelques fonctions pour travailler avec cette structure. Enfin, nous allons Ã©crire une fonction qui convertit un tableau de chaÃ®nes de caractÃ¨res en un tableau de nos structures.

La premiÃ¨re chose Ã  faire est de dÃ©finir notre structure. Nous le faisons dans un fichier d'en-tÃªte, afin que nous puissions l'inclure dans d'autres fichiers source si nÃ©cessaire. Voici notre fichier `ft_stock_str.h`:

```c
#ifndef FT_STOCK_STR_H
# define FT_STOCK_STR_H

// DÃ©finir la structure s_stock_str
typedef struct s_stock_str
{
    int size;    // Taille de la chaÃ®ne
    char *str;   // Pointeur vers la chaÃ®ne originale
    char *copy;  // Pointeur vers une copie de la chaÃ®ne
}   t_stock_str;

#endif
```

Ensuite, nous Ã©crivons les fonctions pour travailler avec cette structure. Nous les mettons dans un fichier source distinct, appelÃ© `ft_stock_str.c`:

```c
#include <stdlib.h>
#include <unistd.h>
#include "ft_stock_str.h"

// Affiche un caractÃ¨re Ã  la console
void ft_putchar(char c)
{
    write(1, &c, 1);
}

// Affiche une chaÃ®ne de caractÃ¨res Ã  la console
void ft_putstr(char *str)
{
    while(*str)
    {
        ft_putchar(*str);
        str++;
    }
}

// Retourne la longueur d'une chaÃ®ne de caractÃ¨res
int ft_strlen(char *str)
{
    int length = 0;
    while (*str++)
        length++;
    return length;
}

// CrÃ©e une nouvelle chaÃ®ne de caractÃ¨res qui est une copie de la chaÃ®ne passÃ©e en paramÃ¨tre
char *ft_strdup(char *src)
{
    int i = 0;
    char *dest = malloc(sizeof(char) * (ft_strlen(src) + 1));

    if (!dest)
        return NULL;

    while (src[i])
    {
        dest[i] = src[i];
        i++;
    }
    dest[i] = '\0';
    return dest;
}

// CrÃ©e un tableau de structures t_stock_str Ã  partir d'un tableau de chaÃ®nes de caractÃ¨res
t_stock_str *ft_strs_to_tab(int ac, char **av)
{
    t_stock_str *tab;
    int i;

    // Allouer de la mÃ©moire pour le tableau
    tab = malloc(sizeof(t_stock_str) * (ac + 1));
    if (!tab)
        return NULL;

    // Remplir le tableau
    i = 0;
    while (i < ac)
    {
        tab[i].size = ft_strlen(av[i]);
        tab[i].str = av[i];
        tab[i].copy = ft_strdup(av[i]);
        if (!tab[i].copy)
        {
            while (i-- > 0)
                free(tab[i].copy);
            free(tab);
            return NULL;
        }
        i++;
    }

    // Terminer le tableau avec une structure vide
    tab[i].str = 0;
    return tab;
}
```

`ft_putchar` Ã©crit un seul caractÃ¨re Ã  la sortie standard. Cette fonction est trÃ¨s utile pour afficher des caractÃ¨res Ã  l'Ã©cran.

Ensuite, nous avons `ft_putstr` qui utilise `ft_putchar` pour Ã©crire une chaÃ®ne de caractÃ¨res entiÃ¨re Ã  la sortie standard. Elle le fait en parcourant chaque caractÃ¨re de la chaÃ®ne et en l'envoyant Ã  `ft_putchar` pour Ãªtre affichÃ©.

La fonction `ft_strlen` retourne la longueur d'une chaÃ®ne de caractÃ¨res. Elle le fait en parcourant chaque caractÃ¨re de la chaÃ®ne jusqu'Ã  ce qu'elle atteigne le caractÃ¨re de terminaison de chaÃ®ne (le caractÃ¨re nul '\0'). Le nombre de caractÃ¨res parcourus est la longueur de la chaÃ®ne.

La fonction `ft_strdup` crÃ©e une nouvelle chaÃ®ne de caractÃ¨res qui est une copie de la chaÃ®ne passÃ©e en paramÃ¨tre. Elle alloue d'abord de la mÃ©moire pour la nouvelle chaÃ®ne, puis elle copie les caractÃ¨res de la chaÃ®ne source dans la nouvelle chaÃ®ne.

Enfin, nous avons la fonction `ft_strs_to_tab`. Cette fonction est un peu plus complexe car elle utilise toutes les autres fonctions que nous avons dÃ©finies. Elle convertit un tableau de chaÃ®nes de caractÃ¨res en un tableau de structures `t_stock_str`. Chaque structure dans le tableau contient une chaÃ®ne de caractÃ¨res, sa longueur et une copie de la chaÃ®ne.


## Exercice 05 : ft_show_tab


Le but de l'exercice est de dÃ©velopper un programme qui utilise une structure dÃ©finie pour stocker et manipuler des points dans un espace Ã  deux dimensions. La structure est dÃ©finie comme suit dans le fichier d'en-tÃªte (`ft_point.h`):

```C
#ifndef FT_POINT_H
# define FT_POINT_H

typedef struct s_point
{
	int	x;
	int	y;
}				t_point;

#endif
```

Ici, nous avons dÃ©fini une structure `s_point` qui contient deux variables entiÃ¨res `x` et `y`. Ensuite, nous avons utilisÃ© le mot-clÃ© `typedef` pour crÃ©er un alias pour cette structure, ce qui nous permet de la dÃ©clarer plus simplement Ã  l'avenir.

Prenons l'exemple d'une fonction qui prend une structure `t_point` comme argument et affiche les coordonnÃ©es du point:

```C
#include "ft_point.h"
#include <stdio.h>

void display_point(t_point pt)
{
    printf("Point coordinates: (%d, %d)\n", pt.x, pt.y);
}
```

Cette fonction prend en paramÃ¨tre une structure `t_point` et utilise la fonction `printf` pour afficher les valeurs de `x` et `y` contenues dans la structure. Notez que vous pouvez accÃ©der aux membres de la structure en utilisant le point `.`.

Maintenant, si nous voulons utiliser cette fonction dans notre programme principal, nous pouvons le faire de cette faÃ§on:

```C
#include "ft_point.h"

int main()
{
    t_point pt;

    pt.x = 5;
    pt.y = 10;

    display_point(pt);

    return 0;
}
```

Dans le programme principal, nous dÃ©clarons une variable `pt` de type `t_point`, puis nous attribuons des valeurs Ã  `x` et `y`. Ensuite, nous appelons la fonction `display_point` pour afficher les coordonnÃ©es du point.

VoilÃ  un exemple de la faÃ§on dont vous pouvez dÃ©finir une structure dans un fichier d'en-tÃªte, puis l'utiliser pour stocker et manipuler des donnÃ©es dans votre programme. Cette approche rend votre code plus organisÃ© et plus facile Ã  comprendre et Ã  maintenir.


Voici comment vous crÃ©ez le fichier d'en-tÃªte:

1. Ouvrez un nouveau fichier et nommez-le `ft_point.h`.

2. Dans `ft_point.h`, commencez par dÃ©finir une structure qui reprÃ©sente un point. En C, une structure est un regroupement de variables sous un seul nom. Dans ce cas, chaque point a deux coordonnÃ©es, `x` et `y`, donc votre structure doit avoir deux variables entiÃ¨res. 

```C
typedef struct s_point
{
	int	x;
	int	y;
}				t_point;
```

3. Lorsque vous dÃ©finissez quelque chose dans un fichier d'en-tÃªte, il est important d'ajouter une condition de prÃ©processeur pour s'assurer qu'il n'est pas dÃ©fini deux fois. Ajoutez ces lignes en haut de votre fichier :

```C
#ifndef FT_POINT_H
# define FT_POINT_H
```

Et cette ligne en bas de votre fichier :

```C
#endif
```

Maintenant, votre fichier `ft_point.h` complet devrait ressembler Ã  ceci :

```C
#ifndef FT_POINT_H
# define FT_POINT_H

typedef struct s_point
{
	int	x;
	int	y;
}				t_point;

#endif
```

Maintenant, vous pouvez utiliser cette structure dans d'autres fichiers C de votre programme. Pour ce faire, vous devez inclure le fichier d'en-tÃªte `ft_point.h` en haut de chaque fichier C qui utilise la structure `t_point`.

Par exemple, supposons que vous ayez un fichier `main.c` qui utilise la structure `t_point`. Vous pourriez commencer ce fichier avec cette ligne :

```C
#include "ft_point.h"
```

Cela dit au compilateur d'inclure le contenu de `ft_point.h` dans `main.c`. Ainsi, vous pouvez utiliser la structure `t_point` dans `main.c` comme si vous l'aviez dÃ©finie dans `main.c` elle-mÃªme.

Ensuite, vous pouvez dÃ©clarer une variable de type `t_point` dans `main.c`, comme ceci :

```C
t_point pt;
```

Ceci crÃ©e une nouvelle variable `pt` qui est une instance de la structure `t_point`. Vous pouvez alors accÃ©der aux variables `x` et `y` de `pt` comme ceci :

```C
pt.x = 5;
pt.y = 10;
```

Et voilÃ , vous avez crÃ©Ã© une structure dans un fichier d'en-tÃªte et vous l'avez utilisÃ©e dans un autre fichier C. Cette technique est trÃ¨s utile pour organiser votre code, en particulier dans les grands programmes oÃ¹ vous pourriez avoir besoin d'utiliser la mÃªme structure dans de nombreux fichiers C diffÃ©rents.


Supposons que vous vouliez Ã©crire une fonction qui prend deux points et calcule la distance entre eux. Vous pourriez le faire dans un autre fichier C, comme suit :

1. Commencez par inclure le fichier d'en-tÃªte `ft_point.h` et la bibliothÃ¨que `math.h` (qui contient des fonctions mathÃ©matiques que nous utiliserons pour calculer la distance).

```C
#include "ft_point.h"
#include <math.h>
```

2. Ensuite, dÃ©finissez une fonction `distance_between_points` qui prend deux pointeurs vers des instances de `t_point` en arguments. 

```C
double distance_between_points(t_point *p1, t_point *p2) {
    int dx = p1->x - p2->x;
    int dy = p1->y - p2->y;
    return sqrt(dx*dx + dy*dy);
}
```

Dans cette fonction, nous utilisons le symbole `->` pour accÃ©der aux membres `x` et `y` des structures pointÃ©es par `p1` et `p2`. Nous calculons ensuite la diffÃ©rence en `x` (dx) et en `y` (dy) entre les deux points, et nous utilisons la formule de la distance euclidienne pour calculer la distance entre eux.

3. Maintenant, vous pouvez utiliser cette fonction dans `main` pour calculer la distance entre deux points.

```C
int main() {
    t_point pt1 = {5, 10};
    t_point pt2 = {3, 4};

    double distance = distance_between_points(&pt1, &pt2);

    printf("La distance entre les deux points est: %f\n", distance);

    return 0;
}
```

Dans `main`, nous crÃ©ons deux points, `pt1` et `pt2`, et nous appelons `distance_between_points` pour calculer la distance entre eux. Notez que nous devons utiliser le symbole `&` pour obtenir des pointeurs vers `pt1` et `pt2` lorsque nous appelons `distance_between_points`.

