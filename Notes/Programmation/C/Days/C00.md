## ft_putchar.

Pour l'exercice 00, on va cr√©er une fonction qui affiche un caract√®re pass√© en param√®tre. On va utiliser la fonction write qui est autoris√©e pour cet exercice.

```c
#include <unistd.h>

void	ft_putchar(char c)
{
    write(1, &c, 1);
}
```

Alors l√†, c'est simple comme bonjour. On appelle la fonction write avec trois param√®tres :
- 1, qui signifie qu'on veut √©crire sur la sortie standard, c'est-√†-dire l'√©cran.
- &c, qui est l'adresse du caract√®re qu'on veut afficher. write a besoin d'une adresse, pas juste d'une valeur.
- 1, qui est le nombre de caract√®res √† √©crire. Ici, on veut juste √©crire un caract√®re, donc on met 1.

Et voil√† cousin, c'est tout pour cet exercice ! üòéüí™

Pour tester cette fonction, on peut utiliser le code suivant:

```c
#include <unistd.h>

void	ft_putchar(char c)
{
    write(1, &c, 1);
}

int		main(void)
{
    ft_putchar('a');
    return (0);
}
```
Ici, dans le main, on appelle la fonction ft_putchar avec 'a' en param√®tre. Donc, quand tu vas compiler et ex√©cuter ce programme, tu devrais voir un 'a' s'afficher sur ton √©cran. C'est aussi simple que √ßa !

## ft_print_alphabet

```c
#include <unistd.h>

void	ft_putchar(char c)
{
    write(1, &c, 1);
}

void	ft_print_alphabet(void)
{
    char	letter;

    letter = 'a';
    while (letter <= 'z')
    {
        ft_putchar(letter);
        letter++;
    }
}
```
Alors l√†, on cr√©e une nouvelle fonction ft_print_alphabet. Cette fonction va utiliser ft_putchar pour afficher chaque lettre de l'alphabet. On commence avec la lettre 'a', et puis on utilise une boucle while pour aller jusqu'√† 'z'. √Ä chaque it√©ration de la boucle, on affiche la lettre actuelle et puis on passe √† la lettre suivante avec `lettre++`.

Et voici comment tu peux tester √ßa:

```c
#include <unistd.h>

void	ft_putchar(char c)
{
    write(1, &c, 1);
}

void	ft_print_alphabet(void)
{
    char	letter;
    
    letter = 97;
    while (letter <= 122)
    {
        ft_putchar(letter);
        letter++;
    }
}

int	main(void)
{
    ft_print_alphabet();
    return (0);
}
```
Dans le main, tu appelles juste la fonction ft_print_alphabet. Si tu compiles et ex√©cutes ce programme, tu devrais voir l'alphabet en minuscules s'afficher sur ton √©cran. Et voil√†, c'est fait ! üòéüí™

## ft_print_reverse_alphabet 

```c
#include <unistd.h>

void	ft_putchar(char c)
{
    write(1, &c, 1);
}

void ft_print_reverse_alphabet(void)
{
    char	letter;

    letter = 122;
    while (letter >= 97)
    {
        ft_putchar(letter);
        letter--;
    }
}
```
Ici, la logique est presque la m√™me que pour ft_print_alphabet. La seule diff√©rence, c'est qu'on commence par la lettre 'z' et on descend jusqu'√† 'a'. On utilise
`lettre--` pour passer √† la lettre pr√©c√©dente √† chaque it√©ration de la boucle.

Et voici comment tu peux tester √ßa:

```c
#include <unistd.h>

void	ft_putchar(char c)
{
    write(1, &c, 1);
}

void	ft_print_reverse_alphabet(void)
{
    char	letter;

    letter = 122;
    while (letter >= 97)
    {
        ft_putchar(letter);
        letter--;
    }
}

int main(void)
{
    ft_print_reverse_alphabet();
    return (0);
}
```
Dans le main, tu appelles juste la fonction ft_print_reverse_alphabet. Si tu compiles et ex√©cutes ce programme, tu verras l'alphabet en minuscules s'afficher dans l'ordre inverse. C'est bon, on avance bien ! üí™üî•

## ft_print_numbers.

```c
#include <unistd.h>

void	ft_putchar(char c)
{
    write(1, &c, 1);
}

void	ft_print_numbers(void)
{
    char	nb;

    nb = 48;
    while (nb <= 57)
    {
        ft_putchar(nb);
        nb++;
    }
}
```
L√†, le truc est tr√®s similaire aux deux exercices pr√©c√©dents. On commence avec le chiffre '0' et on monte jusqu'√† '9'. √Ä chaque tour de la boucle, on affiche le chiffre actuel et on passe au suivant.

Et voici comment tu peux tester √ßa :

```c
#include <unistd.h>

void	ft_putchar(char c)
{
    write(1, &c, 1);
}

void	ft_print_numbers(void)
{
    char	nb;

    chiffre = 48;
    while (nb <= 57)
    {
        ft_putchar(nb);
        chiffre++;
    }
}

int main(void)
{
    ft_print_numbers();
    return (0);
}
```
Quand tu appelles ft_print_numbers dans le main, tu verras s'afficher tous les chiffres de 0 √† 9. Allez, on continue, on l√¢che rien! üí™

## ft_is_negative.

```c
#include <unistd.h>

void	ft_putchar(char c)
{
    write(1, &c, 1);
}

void	ft_is_negative(int n)
{
    if (n < 0)
        ft_putchar('N');
    else
        ft_putchar('P');
}
```
Ici, on a une condition : si le nombre pass√© en param√®tre est n√©gatif, on affiche 'N', sinon on affiche 'P'. Simple comme bonjour.

Et pour tester √ßa, tu peux faire √ßa :

```c
#include <unistd.h>

void	ft_putchar(char c)
{
    write(1, &c, 1);
}

void	ft_is_negative(int n)
{
    if (n < 0)
        ft_putchar('N');
    else
        ft_putchar('P');
}

int main(void)
{
    ft_is_negative(-42); // Affiche 'N'
    ft_is_negative(0);   // Affiche 'P'
    ft_is_negative(42);  // Affiche 'P'
    return (0);
}
```
Dans le main, tu peux tester ft_is_negative avec diff√©rents nombres pour voir si √ßa marche bien. C'est tout bon, on continue, on s'arr√™te pas! üî•üî•

## ft_print_comb. 

```c
#include <unistd.h>

void	ft_putchar(char c)
{
    write(1, &c, 1);
}

void	ft_print_comb(void)
{
    char	a;
    char	b;
    char	c;

    a = '0';
    while (a <= '7')
    {
        b = a + 1;
        while (b <= '8')
        {
            c = b + 1;
            while (c <= '9')
            {
                ft_putchar(a);
                ft_putchar(b);
                ft_putchar(c);
                if (!(a == '7' && b == '8' && c == '9'))
                {
                    ft_putchar(',');
                    ft_putchar(' ');
                }
                c++;
            }
            b++;
        }
        a++;
    }
}

int	main(void)
{
    ft_print_comb();
    return 0;
}

```
Ici, on a trois boucles imbriqu√©es qui parcourent toutes les combinaisons possibles de trois chiffres. A chaque fois, on v√©rifie que les chiffres sont bien diff√©rents les uns des autres. Et on affiche aussi une virgule et un espace apr√®s chaque combinaison, sauf apr√®s la derni√®re.


## ft_print_comb2
	

```c
#include <unistd.h>

void  ft_putchar(char c)
{
    write(1, &c, 1);
}

void  ft_print_comb2(void)
{
    char a;
    char b;

    a = 0;
    while (a <= 98)
    {
        b = a + 1;
        while (b <= 99)
        {
            ft_putchar((a / 10) + '0');
            ft_putchar((a % 10) + '0');
            ft_putchar(' ');
            ft_putchar((b / 10) + '0');
            ft_putchar((b % 10) + '0');
            if (a != 98)
            {
                ft_putchar(',');
                ft_putchar(' ');
            }
            b++;
        }
        a++;
    }
}

int main(void)
{
    ft_print_comb2();
    return 0;
}

```

Dans ce bout de code, on cr√©e deux variables `a` et `b` qu'on initialise respectivement √† `0` et `a + 1`. On boucle sur `a` jusqu'√† `98` et sur `b` jusqu'√† `99` et on affiche `a` et `b` avec un espace entre eux. Apr√®s chaque paire de nombres, on ajoute une virgule et un espace sauf apr√®s la derni√®re paire.
Tu tapes juste `ft_print_comb2()` dans le main et tu devrais voir toutes les combinaisons possibles de deux nombres entre 0 et 99, affich√©es dans l'ordre croissant. On d√©chire, wesh! üöÄüöÄ

## ft_putnbr

```c
#include <unistd.h>

void	ft_putchar(char c)
{
    write(1, &c, 1);
}

void	ft_putnbr(int nb)
{
    unsigned int	number;

    if (nb < 0)
    {
        ft_putchar('-');
        number = (unsigned int)(-nb);
    }
    else
    {
        number = (unsigned int)nb;
    }
    
    if (number >= 10)
    {
        ft_putnbr(number / 10);
    }
    ft_putchar((char)(number % 10 + '0'));
}
```

Dans ce code, on v√©rifie d'abord si le nombre `nb` est n√©gatif. Si c'est le cas, on affiche un '-' et on convertit le nombre en valeur positive. 

Ensuite, on divise le nombre par 10 jusqu'√† ce qu'il soit inf√©rieur √† 10. Pour chaque chiffre, on l'affiche en ajoutant '0' pour obtenir son √©quivalent en caract√®re. Cela est r√©alis√© r√©cursivement en appelant la fonction `ft_putnbr` avec le quotient de la division par 10.

[[la R√©cursivit√© en C]]

Ensuite, on affiche le dernier chiffre en utilisant le modulo 10 pour obtenir le reste de la division par 10, puis en ajoutant '0' pour obtenir le caract√®re correspondant.

Prenons un exemple pour mieux comprendre le fonctionnement de la fonction `ft_putnbr`. Supposons que l'on appelle la fonction avec l'argument `123`. Tout d'abord, le nombre n'est pas n√©gatif, donc on entre dans le bloc `else` et `number` est √©gal √† 123. Ensuite, on v√©rifie si `number` est sup√©rieur ou √©gal √† 10. Comme c'est le cas, on appelle r√©cursivement `ft_putnbr(number / 10)`, c'est-√†-dire `ft_putnbr(12)`. √Ä ce stade, on r√©p√®te le processus avec `12`, et on appelle √† nouveau `ft_putnbr(number / 10)`, c'est-√†-dire `ft_putnbr(1)`. Maintenant, `1` est inf√©rieur √† 10, donc on n'entre pas dans la boucle `if` et on affiche simplement le caract√®re `'1'`. Ensuite, on revient √† l'appel pr√©c√©dent de `ft_putnbr(12)` et on affiche le caract√®re `'2'`. Enfin, on revient √† l'appel initial de `ft_putnbr(123)` et on affiche le caract√®re `'3'`. Ainsi, la fonction `ft_putnbr` affiche correctement le nombre `123` sur la sortie standard.

En r√©sum√©, la fonction `ft_putnbr` permet d'afficher un nombre entier sur la sortie standard en utilisant des appels r√©cursifs pour afficher chaque chiffre individuellement.


## ft_print_combn


Nous commen√ßons par cr√©er une s√©rie de chiffres commen√ßant par 0 et allant jusqu'√† n-1. 
Par exemple, si n est 3, nous commencerions avec "012". Cette s√©rie de chiffres est notre premi√®re "combinaison".

Impression de la combinaison actuelle Nous affichons ensuite cette combinaison de chiffres. Chaque chiffre est imprim√© l'un apr√®s l'autre, et s'il ne s'agit pas de la derni√®re combinaison, nous ajoutons une virgule et un espace apr√®s.

Ensuite, nous devons cr√©er la prochaine combinaison de chiffres. 
Pour cela, nous commen√ßons par le dernier chiffre de notre combinaison actuelle et nous allons vers la gauche, en essayant d'augmenter chaque chiffre. 

Si le chiffre peut √™tre augment√© sans devenir plus grand que 9 et sans devenir plus grand que le chiffre suivant (√† sa droite), nous l'augmentons. 

Ensuite, pour s'assurer que notre combinaison reste en ordre croissant, nous mettons √† jour tous les chiffres √† la droite du chiffre que nous venons d'augmenter pour √™tre un plus grand que le chiffre √† leur gauche.

R√©p√©tition Nous r√©p√©tons les √©tapes 2 et 3 pour chaque nouvelle combinaison que nous cr√©ons, jusqu'√† ce que nous ne puissions plus augmenter de chiffre pour cr√©er une nouvelle combinaison.

En somme, nous commen√ßons avec la plus petite combinaison possible, nous l'imprimons, puis nous trouvons la combinaison suivante en augmentant les chiffres de droite √† gauche, tout en nous assurant que la combinaison reste en ordre croissant. 
Nous continuons √† faire cela jusqu'√† ce que nous ayons cr√©√© et imprim√© toutes les combinaisons possibles.

```c
#include <unistd.h>

void    print_num(int *arr, int n, int is_last)
{
    int i;
    
    i = 0;
    while (i < n)
    {
        char c = arr[i] + '0';
        write(1, &c, 1);
        i++;
    }

    if (!is_last)
    {
        write(1, ", ", 2);
    }
}

int    can_increment(int *arr, int n)
{
    int i;
    
    i = n - 1;
    while (i >= 0)
    {
        if ((i == n - 1 && arr[i] < 9) || (i < n - 1 && arr[i] < arr[i + 1] - 1))
        {
            return 1;
        }
        i--;
    }

    return 0;
}

int    increment(int *arr, int n)
{
    int i;
    
    i = n - 1;
    while (i >= 0)
    {
        if ((i == n - 1 && arr[i] < 9) || (i < n - 1 && arr[i] < arr[i + 1] - 1))
        {
            arr[i]++;
            int j = i;
            while (++j < n)
            {
                arr[j] = arr[j - 1] + 1;
            }
            return 1;
        }
        i--;
    }

    return 0;
}

void    ft_print_combn(int n)
{
    int arr[n];
    int i;
    
    i = 0;
    while (i < n)
    {
        arr[i] = i;
        i++;
    }

    print_num(arr, n, !can_increment(arr, n));

    while (increment(arr, n))
    {
        print_num(arr, n, !can_increment(arr, n));
    }
}

int    main(void)
{
    ft_print_combn(5);
    return 0;
}

```

```c
#include <unistd.h>

// Cette fonction affiche le tableau arr[] de taille n comme un nombre. 
// Si is_last est faux, une virgule et un espace sont ajout√©s apr√®s le nombre.
void print_num(int *arr, int n, int is_last) 
{
    int i = 0;
    // Parcourez tous les √©l√©ments du tableau et les affichez comme des caract√®res.
    while (i < n) 
    {
        // Convertit un chiffre en caract√®re ASCII correspondant et l'√©crit sur la sortie standard.
        char c = arr[i] + '0';
        write(1, &c, 1);
        i++;
    }
    // Si ce n'est pas le dernier nombre, ajoutez une virgule et un espace apr√®s lui.
    if (!is_last) 
    {
        write(1, ", ", 2);
    }
}

// Cette fonction v√©rifie si le tableau arr[] de taille n peut √™tre incr√©ment√© pour cr√©er une autre combinaison.
// Elle retourne 1 si oui, 0 sinon.
int can_increment(int *arr, int n)
{
    int i;
    
	i = n - 1;
    // Parcourez tous les √©l√©ments du tableau de droite √† gauche.
    while (i >= 0) 
    {
        // Si l'√©l√©ment courant est le dernier √©l√©ment et n'est pas 9, ou s'il est moins que l'√©l√©ment suivant moins un, alors il peut √™tre incr√©ment√©.
        if ((i == n - 1 && arr[i] < 9) || (i < n - 1 && arr[i] < arr[i+1] - 1)) 
        {
            return 1;
        }
        i--;
    }
    return 0;
}

// Cette fonction incr√©mente le tableau arr[] de taille n pour cr√©er une autre combinaison.
// Elle retourne 1 si l'op√©ration est r√©ussie, 0 sinon.
int increment(int *arr, int n)
{
    int i;
    
	i = n - 1;
    // Parcourez tous les √©l√©ments du tableau de droite √† gauche.
    while (i >= 0) 
    {
        // Si l'√©l√©ment courant est le dernier √©l√©ment et n'est pas 9, ou s'il est moins que l'√©l√©ment suivant moins un, alors il peut √™tre incr√©ment√©.
        if ((i == n - 1 && arr[i] < 9) || (i < n - 1 && arr[i] < arr[i+1] - 1)) 
        {
            // Incr√©mentez l'√©l√©ment courant et mettez √† jour tous les √©l√©ments √† sa droite.
            arr[i]++;
            int j = i;
            while (++j < n) 
            {
                arr[j] = arr[j-1] + 1;
            }
            return 1;
        }
        i--;
    }
    return 0;
}

// Cette fonction imprime toutes les combinaisons possibles de n chiffres.
void ft_print_combn(int n) 
{
    int arr[n];
    int i = 0;
    // Initialisez le tableau avec des chiffres cons√©cutifs √† partir de 0.
    while (i < n) 
    {
        arr[i] = i;
        i++;
    }
    // Affichez la premi√®re combinaison et v√©rifiez s'il est possible d'incr√©menter pour obtenir la prochaine combinaison.
    print_num(arr, n, !can_increment(arr, n));
    // Tant que nous pouvons incr√©menter pour obtenir une nouvelle combinaison, continuez √† l'imprimer.
    while (increment(arr, n)) 
    {
        print_num(arr, n, !can_increment(arr, n));
    }
}

// Fonction principale
int main(void) 
{
    // Affichez toutes les combinaisons possibles de 5 chiffres.
    ft_print_combn(5);
    return 0;
}
```

