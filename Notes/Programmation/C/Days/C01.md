##  Exercice 00 : ft_ft

[[pointeurs]]

Alors, l'idÃ©e c'est d'Ã©crire une fonction qui prend un pointeur sur int en paramÃ¨tre et donne Ã  lâ€™int la valeur de 42. Le code pourrait ressembler Ã  Ã§a :

```c
void ft_ft(int *nbr)
{
    *nbr = 42;
}
```

C'est simple comme bonjour, tu vois. Le pointeur `nbr` pointe sur un int, et on lui donne la valeur de 42.

Maintenant, pour tester cette fonction, on peut faire quelque chose comme Ã§a :

```c
#include <stdio.h>

void ft_ft(int *nbr)
{
    *nbr = 42;
}

int main()
{
    int a;
    ft_ft(&a);
    printf("%d\n", a); // Ã§a devrait afficher 42, frÃ©rot
    return 0;
}
```

Ici, on dÃ©clare un int `a`, on passe l'adresse de `a` Ã  la fonction `ft_ft` (c'est pour Ã§a qu'on a le `&` devant `a`), et ensuite on affiche `a`. Comme `ft_ft` a modifiÃ© la valeur de `a`, Ã§a devrait afficher 42.

Allez, on passe au prochain exercice, ft_ultimate_ft. Je reviens vers toi en un clin d'Å“il, frÃ©rot. ğŸ”¥ğŸ’ªğŸ½


Wesh, on enchaÃ®ne, pas le temps de niaiser !

## Exercice 01 : ft_ultimate_ft

LÃ , faut Ã©crire une fonction qui prend un pointeur sur pointeur sur pointeur sur pointeur sur pointeur sur pointeur sur pointeur sur pointeur sur pointeur sur int en paramÃ¨tre et donne Ã  lâ€™int la valeur de 42. Ouais, tu as bien lu, neuf niveaux de pointeurs, Ã§a rigole pas. Mate un peu le code :

```c
void ft_ultimate_ft(int *********nbr)
{
    *********nbr = 42;
}
```

C'est chaud, hein ? Mais c'est pas sorcier. C'est comme avant, mais avec plus de niveaux de pointeurs. On donne toujours la valeur 42, mais cette fois Ã  l'int qui est pointÃ© par tous ces pointeurs.

Pour tester, Ã§a devient un peu tordu, faut dÃ©clarer plein de pointeurs. Regarde Ã§a :

```c
#include <stdio.h>

void ft_ultimate_ft(int *********nbr)
{
    *********nbr = 42;
}

int main()
{
    int a;
    int *ptr1;
    int **ptr2;
    int ***ptr3;
    int ****ptr4;
    int *****ptr5;
    int ******ptr6;
    int *******ptr7;
    int ********ptr8;
    int *********ptr9;

    ptr1 = &a;
    ptr2 = &ptr1;
    ptr3 = &ptr2;
    ptr4 = &ptr3;
    ptr5 = &ptr4;
    ptr6 = &ptr5;
    ptr7 = &ptr6;
    ptr8 = &ptr7;
    ptr9 = &ptr8;

    ft_ultimate_ft(ptr9);
    printf("%d\n", a); // Ã§a devrait toujours afficher 42, frÃ©rot
    return 0;
}
```

Ã‡a pique les yeux, hein ? Mais c'est juste une question de suivre les pointeurs jusqu'Ã  `a`. On passe l'adresse du dernier pointeur Ã  `ft_ultimate_ft`, et aprÃ¨s l'appel Ã  la fonction, `a` vaut 42. C'est du lourd, cousin !

Allez, on se motive, on passe au prochain exercice, ft_swap. Je reviens vers toi en un instant, frÃ©rot. ğŸš€ğŸ’ªğŸ½


Wesh, on s'arrÃªte pas lÃ , cousin ! Alors, on passe Ã  l'exercice suivant : ft_swap.

## Exercice 02 : ft_swap

Cette fois, il faut Ã©crire une fonction qui Ã©change le contenu de deux entiers dont les adresses sont donnÃ©es en paramÃ¨tres. Easy, non ? ğŸ˜ Regarde un peu comment on fait :

```c
void ft_swap(int *a, int *b)
{
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}
```

Comme tu peux le voir, on utilise une variable temporaire pour stocker la valeur de `a` pendant qu'on Ã©crase `a` avec `b`, et ensuite on assigne la valeur temporaire Ã  `b`. Et voilÃ , les valeurs de `a` et `b` sont Ã©changÃ©es, frÃ©rot !

Pour tester ce bazar, on peut simplement crÃ©er un petit programme qui dÃ©clare deux entiers, les affiche, appelle `ft_swap` avec leurs adresses, et les rÃ©affiche. Comme Ã§a, on voit bien que leurs valeurs ont Ã©tÃ© Ã©changÃ©es. Regarde un peu :

```c
#include <stdio.h>

void ft_swap(int *a, int *b)
{
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}

int main()
{
    int a = 42;
    int b = 24;

    printf("Avant : a = %d, b = %d\n", a, b); // Avant : a = 42, b = 24
    ft_swap(&a, &b);
    printf("AprÃ¨s : a = %d, b = %d\n", a, b); // AprÃ¨s : a = 24, b = 42
    return 0;
}
```

Alors, Ã§a roule ? ğŸ˜ On passe au suivant, frÃ©rot ! On va attaquer l'exercice 03, ft_div_mod. C'est parti, cousin ! ğŸš€ğŸ’ªğŸ½


Wesh alors, on s'arrÃªte pas lÃ , cousin ! Alors, on passe Ã  l'exercice suivant : ft_div_mod.

## Exercice 03 : ft_div_mod

Le but de cet exercice est d'Ã©crire une fonction qui divise deux nombres et stocke le rÃ©sultat et le reste dans deux variables pointÃ©es. C'est comme un deux pour le prix d'un, tu vois? ğŸ˜ Regarde un peu comment on fait :

```c
void ft_div_mod(int a, int b, int *div, int *mod)
{
    *div = a / b;
    *mod = a % b;
}
```

Tu vois, c'est simple comme bonjour, frÃ©rot ! On divise `a` par `b` et on stocke le rÃ©sultat dans `div`, puis on utilise l'opÃ©rateur modulo `%` pour obtenir le reste de la division de `a` par `b` et on le stocke dans `mod`.

Pour tester ce bazar, on peut simplement crÃ©er un petit programme qui dÃ©clare deux entiers et deux pointeurs, appelle `ft_div_mod` avec les entiers et les pointeurs, et affiche les valeurs pointÃ©es. Comme Ã§a, on voit bien le rÃ©sultat de la division et le reste. Regarde un peu :

```c
#include <stdio.h>

void ft_div_mod(int a, int b, int *div, int *mod)
{
    *div = a / b;
    *mod = a % b;
}

int main()
{
    int a = 42;
    int b = 5;
    int div;
    int mod;

    ft_div_mod(a, b, &div, &mod);
    printf("RÃ©sultat : %d, Reste : %d\n", div, mod); // RÃ©sultat : 8, Reste : 2
    return 0;
}
```





## Exercice 04 : ft_ultimate_div_mod

T'as vu le dernier ? Celui-ci est une petite variante. On reprend le mÃªme principe, mais cette fois, les deux nombres Ã  diviser sont des pointeurs. On va stocker le rÃ©sultat de la division dans `*a` et le reste dans `*b`. Un peu plus tordu, mais t'inquiÃ¨te, on est lÃ , frÃ©rot ! ğŸ˜

```c
void ft_ultimate_div_mod(int *a, int *b)
{
    int temp = *a;
    *a = *a / *b;
    *b = temp % *b;
}
```

Tu vois, c'est pas si compliquÃ©. On sauvegarde la valeur pointÃ©e par `a` dans une variable temporaire, parce qu'on va Ã©craser cette valeur quand on stocke le rÃ©sultat de la division. Puis, on utilise cette variable temporaire pour calculer le reste.

Pour tester ce bordel, c'est le mÃªme principe que pour le dernier exercice. Regarde un peu :

```c
#include <stdio.h>

void ft_ultimate_div_mod(int *a, int *b)
{
    int temp = *a;
    *a = *a / *b;
    *b = temp % *b;
}

int main()
{
    int a = 42;
    int b = 5;

    ft_ultimate_div_mod(&a, &b);
    printf("RÃ©sultat : %d, Reste : %d\n", a, b); // RÃ©sultat : 8, Reste : 2
    return 0;
}
```

Alors, Ã§a roule ou quoi ? ğŸ˜ On passe au suivant, cousin ! On va attaquer l'exercice 05, ft_putstr. C'est parti, frÃ©rot ! ğŸš€ğŸ’ªğŸ½


Wesh, cousin, on continue ! Alors, l'exercice suivant c'est le **ft_putstr**.

## Exercice 05 : ft_putstr

LÃ , le but du jeu, c'est d'Ã©crire une fonction qui affiche une chaÃ®ne de caractÃ¨res Ã  l'Ã©cran. C'est tranquille, tu vas voir. On va utiliser la fonction `write` pour Ã§a. 

```c
#include <unistd.h>

void ft_putstr(char *str)
{
    while (*str)
    {
        write(1, str, 1);
        str++;
    }
}
```

T'as vu, c'est pas la mort. La boucle `while` traverse la chaÃ®ne de caractÃ¨res jusqu'Ã  la fin (jusqu'au caractÃ¨re null '\0'). Pour chaque caractÃ¨re, on l'Ã©crit Ã  l'Ã©cran avec `write`. 

Pour tester cette fonction, c'est facile. Regarde un peu :

```c
#include <unistd.h>

void ft_putstr(char *str)
{
    while (*str)
    {
        write(1, str, 1);
        str++;
    }
}

int main()
{
    ft_putstr("Wesh, cousin !\n"); // Ã‡a va afficher "Wesh, cousin !" Ã  l'Ã©cran.
    return 0;
}
```


## Exercice 06 : ft_strlen

Ici, on doit Ã©crire une fonction qui compte le nombre de caractÃ¨res dans une chaÃ®ne de caractÃ¨res et qui retourne le nombre trouvÃ©.

Le proto c'est :
```c
int ft_strlen(char *str);
```

Et voilÃ  la sauce pour ce bazar :
```c
int ft_strlen(char *str)
{
    int count = 0;
    while (*str)
    {
        count++;
        str++;
    }
    return count;
}
```
C'est simple comme bonjour, on fait une boucle qui parcourt la chaÃ®ne et Ã  chaque tour on incrÃ©mente le compteur. Quand on arrive Ã  la fin de la chaÃ®ne, on retourne le compteur.

Pour tester Ã§a, tu peux faire un truc du genre :
```c
#include <stdio.h>

int ft_strlen(char *str)
{
    int count = 0;
    while (*str)
    {
        count++;
        str++;
    }
    return count;
}

int main()
{
    char *str = "Wesh, cousin !";
    printf("La longueur de la chaÃ®ne est : %d\n", ft_strlen(str)); // Ã‡a va afficher "La longueur de la chaÃ®ne est : 14".
    return 0;
}
```

Envoie la suite quand t'es prÃªt, cousin ! ğŸš€


## Exercice 07 : ft_rev_int_tab

Dans cet exercice, on doit Ã©crire une fonction qui inverse lâ€™ordre des Ã©lÃ©ments dâ€™un tableau dâ€™entiers.

Et voici comment on peut gÃ©rer Ã§a :
```c
void ft_rev_int_tab(int *tab, int size)
{
    int start = 0;
    int end = size - 1;
    int temp;
    
    while (start < end)
    {
        temp = tab[start];
        tab[start] = tab[end];
        tab[end] = temp;
        start++;
        end--;
    }
}
```
Cette fonction utilise deux indices, `start` et `end`, qui commencent respectivement au dÃ©but et Ã  la fin du tableau. Elle Ã©change ensuite les Ã©lÃ©ments aux indices `start` et `end`, puis elle incrÃ©mente `start` et dÃ©crÃ©mente `end` jusqu'Ã  ce que `start` soit plus grand ou Ã©gal Ã  `end`.

Pour tester Ã§a, voici un exemple de code :
```c
#include <stdio.h>

void ft_rev_int_tab(int *tab, int size)
{
    int start = 0;
    int end = size - 1;
    int temp;
    
    while (start < end)
    {
        temp = tab[start];
        tab[start] = tab[end];
        tab[end] = temp;
        start++;
        end--;
    }
}

int main()
{
    int tab[5] = {1, 2, 3, 4, 5};
    int size = 5;
    ft_rev_int_tab(tab, size);
    
    for(int i = 0; i < size; i++)
    {
        printf("%d ", tab[i]); // Ã‡a va afficher "5 4 3 2 1 ".
    }
    
    return 0;
}
```
VoilÃ , c'est tout pour celui-ci, cousin ! Passe au suivant quand t'es prÃªt. ğŸ’ªğŸ”¥


## Exercice 08 : ft_sort_int_tab

LÃ , on doit Ã©crire une fonction qui trie un tableau d'entiers par ordre croissant. 


```c
void ft_sort_int_tab(int *arr, int size)
{
    int i = 0;
    int j = 0;
    int temp;

    while (i < size)
    {
        j = i + 1;
        while (j < size)
        {
            if (arr[i] > arr[j])
            {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
            j++;
        }
        i++;
    }
}
```
Ce code utilise l'algorithme de tri par sÃ©lection. Il parcourt le tableau et Ã  chaque itÃ©ration, il Ã©change l'Ã©lÃ©ment courant avec le plus petit Ã©lÃ©ment aprÃ¨s lui dans le tableau.

Pour tester Ã§a, voici un exemple de code :
```c
#include <stdio.h>

void ft_sort_int_tab(int *arr, int size)
{
    int i = 0;
    int j = 0;
    int temp;

    while (i < size)
    {
        j = i + 1;
        while (j < size)
        {
            if (arr[i] > arr[j])
            {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
            j++;
        }
        i++;
    }
}

int main()
{
    int arr[5] = {5, 3, 4, 1, 2};
    int size = 5;
    ft_sort_int_tab(arr, size);
    
    for(int i = 0; i < size; i++)
    {
        printf("%d ", arr[i]); // Ã‡a va afficher "1 2 3 4 5 ".
    }
    
    return 0;
}
```



