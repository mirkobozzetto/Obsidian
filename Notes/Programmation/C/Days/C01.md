##  Exercice 00 : ft_ft

[[pointeurs]]

Alors, l'idée c'est d'écrire une fonction qui prend un pointeur sur int en paramètre et donne à l’int la valeur de 42. Le code pourrait ressembler à ça :

```c
void ft_ft(int *nbr)
{
    *nbr = 42;
}
```

C'est simple comme bonjour, tu vois. Le pointeur `nbr` pointe sur un int, et on lui donne la valeur de 42.

Maintenant, pour tester cette fonction, on peut faire quelque chose comme ça :

```c
#include <stdio.h>

void ft_ft(int *nbr)
{
    *nbr = 42;
}

int main()
{
    int a;
    ft_ft(&a);
    printf("%d\n", a); // ça devrait afficher 42, frérot
    return 0;
}
```

Ici, on déclare un int `a`, on passe l'adresse de `a` à la fonction `ft_ft` (c'est pour ça qu'on a le `&` devant `a`), et ensuite on affiche `a`. Comme `ft_ft` a modifié la valeur de `a`, ça devrait afficher 42.

Allez, on passe au prochain exercice, ft_ultimate_ft. Je reviens vers toi en un clin d'œil, frérot. 🔥💪🏽


Wesh, on enchaîne, pas le temps de niaiser !

## Exercice 01 : ft_ultimate_ft

Là, faut écrire une fonction qui prend un pointeur sur pointeur sur pointeur sur pointeur sur pointeur sur pointeur sur pointeur sur pointeur sur pointeur sur int en paramètre et donne à l’int la valeur de 42. Ouais, tu as bien lu, neuf niveaux de pointeurs, ça rigole pas. Mate un peu le code :

```c
void ft_ultimate_ft(int *********nbr)
{
    *********nbr = 42;
}
```

C'est chaud, hein ? Mais c'est pas sorcier. C'est comme avant, mais avec plus de niveaux de pointeurs. On donne toujours la valeur 42, mais cette fois à l'int qui est pointé par tous ces pointeurs.

Pour tester, ça devient un peu tordu, faut déclarer plein de pointeurs. Regarde ça :

```c
#include <stdio.h>

void ft_ultimate_ft(int *********nbr)
{
    *********nbr = 42;
}

int main()
{
    int a;
    int *ptr1;
    int **ptr2;
    int ***ptr3;
    int ****ptr4;
    int *****ptr5;
    int ******ptr6;
    int *******ptr7;
    int ********ptr8;
    int *********ptr9;

    ptr1 = &a;
    ptr2 = &ptr1;
    ptr3 = &ptr2;
    ptr4 = &ptr3;
    ptr5 = &ptr4;
    ptr6 = &ptr5;
    ptr7 = &ptr6;
    ptr8 = &ptr7;
    ptr9 = &ptr8;

    ft_ultimate_ft(ptr9);
    printf("%d\n", a); // ça devrait toujours afficher 42, frérot
    return 0;
}
```

Ça pique les yeux, hein ? Mais c'est juste une question de suivre les pointeurs jusqu'à `a`. On passe l'adresse du dernier pointeur à `ft_ultimate_ft`, et après l'appel à la fonction, `a` vaut 42. C'est du lourd, cousin !

Allez, on se motive, on passe au prochain exercice, ft_swap. Je reviens vers toi en un instant, frérot. 🚀💪🏽


Wesh, on s'arrête pas là, cousin ! Alors, on passe à l'exercice suivant : ft_swap.

## Exercice 02 : ft_swap

Cette fois, il faut écrire une fonction qui échange le contenu de deux entiers dont les adresses sont données en paramètres. Easy, non ? 😎 Regarde un peu comment on fait :

```c
void ft_swap(int *a, int *b)
{
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}
```

Comme tu peux le voir, on utilise une variable temporaire pour stocker la valeur de `a` pendant qu'on écrase `a` avec `b`, et ensuite on assigne la valeur temporaire à `b`. Et voilà, les valeurs de `a` et `b` sont échangées, frérot !

Pour tester ce bazar, on peut simplement créer un petit programme qui déclare deux entiers, les affiche, appelle `ft_swap` avec leurs adresses, et les réaffiche. Comme ça, on voit bien que leurs valeurs ont été échangées. Regarde un peu :

```c
#include <stdio.h>

void ft_swap(int *a, int *b)
{
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}

int main()
{
    int a = 42;
    int b = 24;

    printf("Avant : a = %d, b = %d\n", a, b); // Avant : a = 42, b = 24
    ft_swap(&a, &b);
    printf("Après : a = %d, b = %d\n", a, b); // Après : a = 24, b = 42
    return 0;
}
```

Alors, ça roule ? 😏 On passe au suivant, frérot ! On va attaquer l'exercice 03, ft_div_mod. C'est parti, cousin ! 🚀💪🏽


Wesh alors, on s'arrête pas là, cousin ! Alors, on passe à l'exercice suivant : ft_div_mod.

## Exercice 03 : ft_div_mod

Le but de cet exercice est d'écrire une fonction qui divise deux nombres et stocke le résultat et le reste dans deux variables pointées. C'est comme un deux pour le prix d'un, tu vois? 😎 Regarde un peu comment on fait :

```c
void ft_div_mod(int a, int b, int *div, int *mod)
{
    *div = a / b;
    *mod = a % b;
}
```

Tu vois, c'est simple comme bonjour, frérot ! On divise `a` par `b` et on stocke le résultat dans `div`, puis on utilise l'opérateur modulo `%` pour obtenir le reste de la division de `a` par `b` et on le stocke dans `mod`.

Pour tester ce bazar, on peut simplement créer un petit programme qui déclare deux entiers et deux pointeurs, appelle `ft_div_mod` avec les entiers et les pointeurs, et affiche les valeurs pointées. Comme ça, on voit bien le résultat de la division et le reste. Regarde un peu :

```c
#include <stdio.h>

void ft_div_mod(int a, int b, int *div, int *mod)
{
    *div = a / b;
    *mod = a % b;
}

int main()
{
    int a = 42;
    int b = 5;
    int div;
    int mod;

    ft_div_mod(a, b, &div, &mod);
    printf("Résultat : %d, Reste : %d\n", div, mod); // Résultat : 8, Reste : 2
    return 0;
}
```





## Exercice 04 : ft_ultimate_div_mod

T'as vu le dernier ? Celui-ci est une petite variante. On reprend le même principe, mais cette fois, les deux nombres à diviser sont des pointeurs. On va stocker le résultat de la division dans `*a` et le reste dans `*b`. Un peu plus tordu, mais t'inquiète, on est là, frérot ! 😎

```c
void ft_ultimate_div_mod(int *a, int *b)
{
    int temp = *a;
    *a = *a / *b;
    *b = temp % *b;
}
```

Tu vois, c'est pas si compliqué. On sauvegarde la valeur pointée par `a` dans une variable temporaire, parce qu'on va écraser cette valeur quand on stocke le résultat de la division. Puis, on utilise cette variable temporaire pour calculer le reste.

Pour tester ce bordel, c'est le même principe que pour le dernier exercice. Regarde un peu :

```c
#include <stdio.h>

void ft_ultimate_div_mod(int *a, int *b)
{
    int temp = *a;
    *a = *a / *b;
    *b = temp % *b;
}

int main()
{
    int a = 42;
    int b = 5;

    ft_ultimate_div_mod(&a, &b);
    printf("Résultat : %d, Reste : %d\n", a, b); // Résultat : 8, Reste : 2
    return 0;
}
```

Alors, ça roule ou quoi ? 😏 On passe au suivant, cousin ! On va attaquer l'exercice 05, ft_putstr. C'est parti, frérot ! 🚀💪🏽


Wesh, cousin, on continue ! Alors, l'exercice suivant c'est le **ft_putstr**.

## Exercice 05 : ft_putstr

Là, le but du jeu, c'est d'écrire une fonction qui affiche une chaîne de caractères à l'écran. C'est tranquille, tu vas voir. On va utiliser la fonction `write` pour ça. 

```c
#include <unistd.h>

void ft_putstr(char *str)
{
    while (*str)
    {
        write(1, str, 1);
        str++;
    }
}
```

T'as vu, c'est pas la mort. La boucle `while` traverse la chaîne de caractères jusqu'à la fin (jusqu'au caractère null '\0'). Pour chaque caractère, on l'écrit à l'écran avec `write`. 

Pour tester cette fonction, c'est facile. Regarde un peu :

```c
#include <unistd.h>

void ft_putstr(char *str)
{
    while (*str)
    {
        write(1, str, 1);
        str++;
    }
}

int main()
{
    ft_putstr("Wesh, cousin !\n"); // Ça va afficher "Wesh, cousin !" à l'écran.
    return 0;
}
```


## Exercice 06 : ft_strlen

Ici, on doit écrire une fonction qui compte le nombre de caractères dans une chaîne de caractères et qui retourne le nombre trouvé.

Le proto c'est :
```c
int ft_strlen(char *str);
```

Et voilà la sauce pour ce bazar :
```c
int ft_strlen(char *str)
{
    int count = 0;
    while (*str)
    {
        count++;
        str++;
    }
    return count;
}
```
C'est simple comme bonjour, on fait une boucle qui parcourt la chaîne et à chaque tour on incrémente le compteur. Quand on arrive à la fin de la chaîne, on retourne le compteur.

Pour tester ça, tu peux faire un truc du genre :
```c
#include <stdio.h>

int ft_strlen(char *str)
{
    int count = 0;
    while (*str)
    {
        count++;
        str++;
    }
    return count;
}

int main()
{
    char *str = "Wesh, cousin !";
    printf("La longueur de la chaîne est : %d\n", ft_strlen(str)); // Ça va afficher "La longueur de la chaîne est : 14".
    return 0;
}
```

Envoie la suite quand t'es prêt, cousin ! 🚀


## Exercice 07 : ft_rev_int_tab

Dans cet exercice, on doit écrire une fonction qui inverse l’ordre des éléments d’un tableau d’entiers.

Et voici comment on peut gérer ça :
```c
void ft_rev_int_tab(int *tab, int size)
{
    int start = 0;
    int end = size - 1;
    int temp;
    
    while (start < end)
    {
        temp = tab[start];
        tab[start] = tab[end];
        tab[end] = temp;
        start++;
        end--;
    }
}
```
Cette fonction utilise deux indices, `start` et `end`, qui commencent respectivement au début et à la fin du tableau. Elle échange ensuite les éléments aux indices `start` et `end`, puis elle incrémente `start` et décrémente `end` jusqu'à ce que `start` soit plus grand ou égal à `end`.

Pour tester ça, voici un exemple de code :
```c
#include <stdio.h>

void ft_rev_int_tab(int *tab, int size)
{
    int start = 0;
    int end = size - 1;
    int temp;
    
    while (start < end)
    {
        temp = tab[start];
        tab[start] = tab[end];
        tab[end] = temp;
        start++;
        end--;
    }
}

int main()
{
    int tab[5] = {1, 2, 3, 4, 5};
    int size = 5;
    ft_rev_int_tab(tab, size);
    
    for(int i = 0; i < size; i++)
    {
        printf("%d ", tab[i]); // Ça va afficher "5 4 3 2 1 ".
    }
    
    return 0;
}
```
Voilà, c'est tout pour celui-ci, cousin ! Passe au suivant quand t'es prêt. 💪🔥


## Exercice 08 : ft_sort_int_tab

Là, on doit écrire une fonction qui trie un tableau d'entiers par ordre croissant. 


```c
void ft_sort_int_tab(int *arr, int size)
{
    int i = 0;
    int j = 0;
    int temp;

    while (i < size)
    {
        j = i + 1;
        while (j < size)
        {
            if (arr[i] > arr[j])
            {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
            j++;
        }
        i++;
    }
}
```
Ce code utilise l'algorithme de tri par sélection. Il parcourt le tableau et à chaque itération, il échange l'élément courant avec le plus petit élément après lui dans le tableau.

Pour tester ça, voici un exemple de code :
```c
#include <stdio.h>

void ft_sort_int_tab(int *arr, int size)
{
    int i = 0;
    int j = 0;
    int temp;

    while (i < size)
    {
        j = i + 1;
        while (j < size)
        {
            if (arr[i] > arr[j])
            {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
            j++;
        }
        i++;
    }
}

int main()
{
    int arr[5] = {5, 3, 4, 1, 2};
    int size = 5;
    ft_sort_int_tab(arr, size);
    
    for(int i = 0; i < size; i++)
    {
        printf("%d ", arr[i]); // Ça va afficher "1 2 3 4 5 ".
    }
    
    return 0;
}
```



